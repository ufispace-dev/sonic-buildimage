From 2ae4383755054e461fac727abf2ceea2b6ab3ae1 Mon Sep 17 00:00:00 2001
From: Carmine Scarpitta <cscarpit@cisco.com>
Date: Tue, 7 Jan 2025 14:23:34 +0100
Subject: [PATCH] staticd: Add support for SRv6

Signed-off-by: Carmine Scarpitta <cscarpit@cisco.com>
---
 lib/command.h                                 |   1 +
 staticd/static_main.c                         |   8 +
 staticd/static_nb.c                           |  29 +
 staticd/static_nb.h                           |  32 +-
 staticd/static_nb_config.c                    | 194 ++++++
 staticd/static_srv6.c                         | 192 ++++++
 staticd/static_srv6.h                         | 125 ++++
 staticd/static_vrf.c                          |   2 +
 staticd/static_vty.c                          | 320 +++++++++
 staticd/static_zebra.c                        | 698 ++++++++++++++++++
 staticd/static_zebra.h                        |  12 +-
 staticd/subdir.am                             |   2 +
 tests/topotests/static_srv6_sids/__init__.py  |   0
 .../static_srv6_sids/expected_srv6_sids.json  | 142 ++++
 .../topotests/static_srv6_sids/r1/mgmtd.conf  |   0
 tests/topotests/static_srv6_sids/r1/setup.sh  |  13 +
 .../static_srv6_sids/r1/staticd.conf          |  16 +
 .../topotests/static_srv6_sids/r1/zebra.conf  |  19 +
 .../static_srv6_sids/test_static_srv6_sids.py |  89 +++
 vtysh/vtysh.c                                 |  38 +-
 yang/frr-staticd.yang                         |  59 +-
 zebra/zebra_srv6.c                            | 124 +++-
 22 files changed, 2032 insertions(+), 21 deletions(-)
 create mode 100644 staticd/static_srv6.c
 create mode 100644 staticd/static_srv6.h
 create mode 100644 tests/topotests/static_srv6_sids/__init__.py
 create mode 100644 tests/topotests/static_srv6_sids/expected_srv6_sids.json
 create mode 100644 tests/topotests/static_srv6_sids/r1/mgmtd.conf
 create mode 100644 tests/topotests/static_srv6_sids/r1/setup.sh
 create mode 100644 tests/topotests/static_srv6_sids/r1/staticd.conf
 create mode 100644 tests/topotests/static_srv6_sids/r1/zebra.conf
 create mode 100755 tests/topotests/static_srv6_sids/test_static_srv6_sids.py

diff --git a/lib/command.h b/lib/command.h
index c60751789f..dfd732893b 100644
--- a/lib/command.h
+++ b/lib/command.h
@@ -154,6 +154,7 @@ enum node_type {
 	PCEP_PCE_NODE,		 /* PCE configuration node */
 	PCEP_PCC_NODE,		 /* PCC configuration node */
 	SRV6_NODE,		 /* SRv6 node */
+	SRV6_SIDS_NODE,		 /* SRv6 SIDs node */
 	SRV6_LOCS_NODE,		 /* SRv6 locators node */
 	SRV6_LOC_NODE,		 /* SRv6 locator node */
 	SRV6_ENCAP_NODE,		 /* SRv6 encapsulation node */
diff --git a/staticd/static_main.c b/staticd/static_main.c
index 9468a98b83..f01bc08fd8 100644
--- a/staticd/static_main.c
+++ b/staticd/static_main.c
@@ -26,6 +26,7 @@
 #include "static_zebra.h"
 #include "static_debug.h"
 #include "static_nb.h"
+#include "static_srv6.h"
 
 #include "mgmt_be_client.h"
 
@@ -76,6 +77,10 @@ static void sigint(void)
 	static_vrf_terminate();
 
 	static_zebra_stop();
+
+	/* clean up SRv6 data structures */
+	static_srv6_cleanup();
+
 	frr_fini();
 
 	exit(0);
@@ -160,6 +165,9 @@ int main(int argc, char **argv, char **envp)
 	static_debug_init();
 	static_vrf_init();
 
+	/* initialize SRv6 data structures */
+	static_srv6_init();
+
 	static_zebra_init();
 	static_vty_init();
 
diff --git a/staticd/static_nb.c b/staticd/static_nb.c
index e6aa71a77b..d607bd8888 100644
--- a/staticd/static_nb.c
+++ b/staticd/static_nb.c
@@ -224,6 +224,35 @@ const struct frr_yang_module_info frr_staticd_info = {
 				.destroy = routing_control_plane_protocols_control_plane_protocol_staticd_route_list_src_list_path_list_frr_nexthops_nexthop_mpls_label_stack_entry_traffic_class_destroy,
 			}
 		},
+		{
+			.xpath = "/frr-routing:routing/control-plane-protocols/control-plane-protocol/frr-staticd:staticd/segment-routing/srv6/local-sids/sid",
+			.cbs = {
+				.apply_finish = routing_control_plane_protocols_control_plane_protocol_staticd_segment_routing_srv6_local_sids_sid_apply_finish,
+				.create = routing_control_plane_protocols_control_plane_protocol_staticd_segment_routing_srv6_local_sids_sid_create,
+				.destroy = routing_control_plane_protocols_control_plane_protocol_staticd_segment_routing_srv6_local_sids_sid_destroy,
+			}
+		},
+		{
+			.xpath = "/frr-routing:routing/control-plane-protocols/control-plane-protocol/frr-staticd:staticd/segment-routing/srv6/local-sids/sid/behavior",
+			.cbs = {
+				.modify = routing_control_plane_protocols_control_plane_protocol_staticd_segment_routing_srv6_local_sids_sid_behavior_modify,
+				.destroy = routing_control_plane_protocols_control_plane_protocol_staticd_segment_routing_srv6_local_sids_sid_behavior_destroy,
+			}
+		},
+		{
+			.xpath = "/frr-routing:routing/control-plane-protocols/control-plane-protocol/frr-staticd:staticd/segment-routing/srv6/local-sids/sid/vrf-name",
+			.cbs = {
+				.modify = routing_control_plane_protocols_control_plane_protocol_staticd_segment_routing_srv6_local_sids_sid_vrf_name_modify,
+				.destroy = routing_control_plane_protocols_control_plane_protocol_staticd_segment_routing_srv6_local_sids_sid_vrf_name_destroy,
+			}
+		},
+		{
+			.xpath = "/frr-routing:routing/control-plane-protocols/control-plane-protocol/frr-staticd:staticd/segment-routing/srv6/local-sids/sid/locator-name",
+			.cbs = {
+				.modify = routing_control_plane_protocols_control_plane_protocol_staticd_segment_routing_srv6_local_sids_sid_locator_name_modify,
+				.destroy = routing_control_plane_protocols_control_plane_protocol_staticd_segment_routing_srv6_local_sids_sid_locator_name_destroy,
+			}
+		},
 		{
 			.xpath = NULL,
 		},
diff --git a/staticd/static_nb.h b/staticd/static_nb.h
index be75d9d38c..fca9f9952c 100644
--- a/staticd/static_nb.h
+++ b/staticd/static_nb.h
@@ -118,6 +118,34 @@ int routing_control_plane_protocols_control_plane_protocol_staticd_route_list_sr
 	struct nb_cb_modify_args *args);
 int routing_control_plane_protocols_control_plane_protocol_staticd_route_list_src_list_path_list_frr_nexthops_nexthop_mpls_label_stack_entry_traffic_class_destroy(
 	struct nb_cb_destroy_args *args);
+int routing_control_plane_protocols_control_plane_protocol_staticd_segment_routing_create(
+	struct nb_cb_create_args *args);
+int routing_control_plane_protocols_control_plane_protocol_staticd_segment_routing_destroy(
+	struct nb_cb_destroy_args *args);
+int routing_control_plane_protocols_control_plane_protocol_staticd_segment_routing_srv6_create(
+	struct nb_cb_create_args *args);
+int routing_control_plane_protocols_control_plane_protocol_staticd_segment_routing_srv6_destroy(
+	struct nb_cb_destroy_args *args);
+int routing_control_plane_protocols_control_plane_protocol_staticd_segment_routing_srv6_local_sids_create(
+	struct nb_cb_create_args *args);
+int routing_control_plane_protocols_control_plane_protocol_staticd_segment_routing_srv6_local_sids_destroy(
+	struct nb_cb_destroy_args *args);
+int routing_control_plane_protocols_control_plane_protocol_staticd_segment_routing_srv6_local_sids_sid_create(
+	struct nb_cb_create_args *args);
+int routing_control_plane_protocols_control_plane_protocol_staticd_segment_routing_srv6_local_sids_sid_destroy(
+	struct nb_cb_destroy_args *args);
+int routing_control_plane_protocols_control_plane_protocol_staticd_segment_routing_srv6_local_sids_sid_behavior_modify(
+	struct nb_cb_modify_args *args);
+int routing_control_plane_protocols_control_plane_protocol_staticd_segment_routing_srv6_local_sids_sid_behavior_destroy(
+	struct nb_cb_destroy_args *args);
+int routing_control_plane_protocols_control_plane_protocol_staticd_segment_routing_srv6_local_sids_sid_vrf_name_modify(
+	struct nb_cb_modify_args *args);
+int routing_control_plane_protocols_control_plane_protocol_staticd_segment_routing_srv6_local_sids_sid_vrf_name_destroy(
+	struct nb_cb_destroy_args *args);
+int routing_control_plane_protocols_control_plane_protocol_staticd_segment_routing_srv6_local_sids_sid_locator_name_modify(
+	struct nb_cb_modify_args *args);
+int routing_control_plane_protocols_control_plane_protocol_staticd_segment_routing_srv6_local_sids_sid_locator_name_destroy(
+	struct nb_cb_destroy_args *args);
 
 /* Optional 'apply_finish' callbacks. */
 
@@ -125,6 +153,8 @@ void routing_control_plane_protocols_control_plane_protocol_staticd_route_list_p
 	struct nb_cb_apply_finish_args *args);
 void routing_control_plane_protocols_control_plane_protocol_staticd_route_list_src_list_path_list_frr_nexthops_nexthop_apply_finish(
 	struct nb_cb_apply_finish_args *args);
+void routing_control_plane_protocols_control_plane_protocol_staticd_segment_routing_srv6_local_sids_sid_apply_finish(
+	struct nb_cb_apply_finish_args *args);
 
 /* Optional 'pre_validate' callbacks. */
 int routing_control_plane_protocols_control_plane_protocol_staticd_route_list_path_list_frr_nexthops_nexthop_pre_validate(
@@ -210,4 +240,4 @@ int routing_control_plane_protocols_name_validate(
 }
 #endif
 
-#endif
+#endif
\ No newline at end of file
diff --git a/staticd/static_nb_config.c b/staticd/static_nb_config.c
index 7de5f0474a..a702dc48f8 100644
--- a/staticd/static_nb_config.c
+++ b/staticd/static_nb_config.c
@@ -20,6 +20,8 @@
 #include "static_nb.h"
 #include "static_zebra.h"
 
+#include "static_srv6.h"
+
 
 static int static_path_list_create(struct nb_cb_create_args *args)
 {
@@ -1367,3 +1369,195 @@ int routing_control_plane_protocols_control_plane_protocol_staticd_route_list_sr
 
 	return NB_OK;
 }
+
+/*
+ * XPath:
+ * /frr-routing:routing/control-plane-protocols/control-plane-protocol/frr-staticd:staticd/segment-routing
+ */
+int routing_control_plane_protocols_control_plane_protocol_staticd_segment_routing_create(
+	struct nb_cb_create_args *args)
+{
+	return NB_OK;
+}
+
+int routing_control_plane_protocols_control_plane_protocol_staticd_segment_routing_destroy(
+	struct nb_cb_destroy_args *args)
+{
+	return NB_OK;
+}
+
+/*
+ * XPath:
+ * /frr-routing:routing/control-plane-protocols/control-plane-protocol/frr-staticd:staticd/segment-routing/srv6
+ */
+int routing_control_plane_protocols_control_plane_protocol_staticd_segment_routing_srv6_create(
+	struct nb_cb_create_args *args)
+{
+	return NB_OK;
+}
+
+int routing_control_plane_protocols_control_plane_protocol_staticd_segment_routing_srv6_destroy(
+	struct nb_cb_destroy_args *args)
+{
+	return NB_OK;
+}
+
+/*
+ * XPath:
+ * /frr-routing:routing/control-plane-protocols/control-plane-protocol/frr-staticd:staticd/segment-routing/srv6/local-sids
+ */
+int routing_control_plane_protocols_control_plane_protocol_staticd_segment_routing_srv6_local_sids_create(
+	struct nb_cb_create_args *args)
+{
+	return NB_OK;
+}
+
+int routing_control_plane_protocols_control_plane_protocol_staticd_segment_routing_srv6_local_sids_destroy(
+	struct nb_cb_destroy_args *args)
+{
+	return NB_OK;
+}
+
+/*
+ * XPath:
+ * /frr-routing:routing/control-plane-protocols/control-plane-protocol/frr-staticd:staticd/segment-routing/srv6/locators/locator/local-sids/sid
+ */
+int routing_control_plane_protocols_control_plane_protocol_staticd_segment_routing_srv6_local_sids_sid_create(
+	struct nb_cb_create_args *args)
+{
+	struct static_srv6_sid *sid;
+	struct prefix_ipv6 sid_value;
+
+	if (args->event != NB_EV_APPLY)
+		return NB_OK;
+
+	yang_dnode_get_ipv6p(&sid_value, args->dnode, "sid");
+	sid = static_srv6_sid_alloc(&sid_value);
+	nb_running_set_entry(args->dnode, sid);
+
+	return NB_OK;
+}
+
+int routing_control_plane_protocols_control_plane_protocol_staticd_segment_routing_srv6_local_sids_sid_destroy(
+	struct nb_cb_destroy_args *args)
+{
+	struct static_srv6_sid *sid;
+
+	if (args->event != NB_EV_APPLY)
+		return NB_OK;
+
+	sid = nb_running_unset_entry(args->dnode);
+	listnode_delete(srv6_sids, sid);
+	static_srv6_sid_del(sid);
+
+	return NB_OK;
+}
+
+void routing_control_plane_protocols_control_plane_protocol_staticd_segment_routing_srv6_local_sids_sid_apply_finish(
+	struct nb_cb_apply_finish_args *args)
+{
+	struct static_srv6_sid *sid;
+	struct static_srv6_locator *locator;
+
+	sid = nb_running_get_entry(args->dnode, NULL, true);
+
+	locator = static_srv6_locator_lookup(sid->locator_name);
+	if (!locator) {
+		zlog_info("Locator not found, trying to get locator information from zebra");
+		static_zebra_srv6_manager_get_locator(sid->locator_name);
+		listnode_add(srv6_sids, sid);
+		return;
+	}
+
+	sid->locator = locator;
+	
+	listnode_add(srv6_sids, sid);
+	static_zebra_request_srv6_sid(sid);
+}
+
+/*
+ * XPath:
+ * /frr-routing:routing/control-plane-protocols/control-plane-protocol/frr-staticd:staticd/segment-routing/srv6/locators/locator/local-sids/sid/behavior
+ */
+int routing_control_plane_protocols_control_plane_protocol_staticd_segment_routing_srv6_local_sids_sid_behavior_modify(
+	struct nb_cb_modify_args *args)
+{
+	struct static_srv6_sid *sid;
+
+	if (args->event != NB_EV_APPLY)
+		return NB_OK;
+
+	sid = nb_running_get_entry(args->dnode, NULL, true);
+
+	/* Release and uninstall existing SID, if any, before requesting the new one */
+	static_zebra_release_srv6_sid(sid);
+	static_zebra_srv6_sid_uninstall(sid);
+
+	sid->behavior = yang_dnode_get_enum(args->dnode, "../behavior");
+
+	return NB_OK;
+}
+
+int routing_control_plane_protocols_control_plane_protocol_staticd_segment_routing_srv6_local_sids_sid_behavior_destroy(
+	struct nb_cb_destroy_args *args)
+{
+	return NB_OK;
+}
+
+/*
+ * XPath:
+ * /frr-routing:routing/control-plane-protocols/control-plane-protocol/frr-staticd:staticd/segment-routing/srv6/locators/locator/local-sids/sid/vrf-name
+ */
+int routing_control_plane_protocols_control_plane_protocol_staticd_segment_routing_srv6_local_sids_sid_vrf_name_modify(
+	struct nb_cb_modify_args *args)
+{
+	struct static_srv6_sid *sid;
+
+	if (args->event != NB_EV_APPLY)
+		return NB_OK;
+
+	sid = nb_running_get_entry(args->dnode, NULL, true);
+
+	/* Release and uninstall existing SID, if any, before requesting the new one */
+	static_zebra_release_srv6_sid(sid);
+	static_zebra_srv6_sid_uninstall(sid);
+
+	strncpy(sid->attributes.vrf_name, yang_dnode_get_string(args->dnode, "../vrf-name"), sizeof(sid->attributes.vrf_name));
+
+	return NB_OK;
+}
+
+int routing_control_plane_protocols_control_plane_protocol_staticd_segment_routing_srv6_local_sids_sid_vrf_name_destroy(
+	struct nb_cb_destroy_args *args)
+{
+	return NB_OK;
+}
+
+/*
+ * XPath:
+ * /frr-routing:routing/control-plane-protocols/control-plane-protocol/frr-staticd:staticd/segment-routing/srv6/locators/locator/local-sids/sid/vrf-name
+ */
+int routing_control_plane_protocols_control_plane_protocol_staticd_segment_routing_srv6_local_sids_sid_locator_name_modify(
+	struct nb_cb_modify_args *args)
+{
+	struct static_srv6_sid *sid;
+
+	if (args->event != NB_EV_APPLY)
+		return NB_OK;
+
+	sid = nb_running_get_entry(args->dnode, NULL, true);
+
+	/* Release and uninstall existing SID, if any, before requesting the new one */
+	static_zebra_release_srv6_sid(sid);
+	static_zebra_srv6_sid_uninstall(sid);
+
+	strncpy(sid->locator_name, yang_dnode_get_string(args->dnode, "../locator-name"), sizeof(sid->locator_name));
+
+	return NB_OK;
+}
+
+int routing_control_plane_protocols_control_plane_protocol_staticd_segment_routing_srv6_local_sids_sid_locator_name_destroy(
+	struct nb_cb_destroy_args *args)
+{
+	return NB_OK;
+}
diff --git a/staticd/static_srv6.c b/staticd/static_srv6.c
new file mode 100644
index 0000000000..eabc8655f7
--- /dev/null
+++ b/staticd/static_srv6.c
@@ -0,0 +1,192 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * STATICd - Segment Routing over IPv6 (SRv6) code
+ */
+#include <zebra.h>
+
+#include "vrf.h"
+#include "nexthop.h"
+
+#include "static_routes.h"
+#include "static_srv6.h"
+#include "static_vrf.h"
+#include "static_zebra.h"
+
+/*
+ * List of SRv6 SIDs.
+ */
+struct list *srv6_locators = NULL;
+struct list *srv6_sids = NULL;
+
+DEFINE_MTYPE_STATIC(STATIC, STATIC_SRV6_LOCATOR, "Static SRv6 locator");
+DEFINE_MTYPE_STATIC(STATIC, STATIC_SRV6_SID, "Static SRv6 SID");
+
+/*
+ * Convert SRv6 behavior to human-friendly string.
+ */
+const char *
+static_srv6_sid_behavior2str(enum static_srv6_sid_behavior_t behavior)
+{
+	switch (behavior) {
+	case STATIC_SRV6_SID_BEHAVIOR_END:
+		return "End";
+	case STATIC_SRV6_SID_BEHAVIOR_END_X:
+		return "End.X";
+	case STATIC_SRV6_SID_BEHAVIOR_END_DT6:
+		return "End.DT6";
+	case STATIC_SRV6_SID_BEHAVIOR_END_DT4:
+		return "End.DT4";
+	case STATIC_SRV6_SID_BEHAVIOR_END_DT46:
+		return "End.DT46";
+	case STATIC_SRV6_SID_BEHAVIOR_UN:
+		return "uN";
+	case STATIC_SRV6_SID_BEHAVIOR_UA:
+		return "uA";
+	case STATIC_SRV6_SID_BEHAVIOR_UDT6:
+		return "uDT6";
+	case STATIC_SRV6_SID_BEHAVIOR_UDT4:
+		return "uDT4";
+	case STATIC_SRV6_SID_BEHAVIOR_UDT46:
+		return "uDT46";
+	case STATIC_SRV6_SID_BEHAVIOR_UNSPEC:
+		return "unspec";
+	}
+
+	return "unspec";
+}
+
+/*
+ * When an interface is enabled in the kernel, go through all the static SRv6 SIDs in
+ * the system that use this interface and install/remove them in the zebra RIB.
+ *
+ * ifp   - The interface being enabled
+ * is_up - Whether the interface is up or down
+ */
+void static_ifp_srv6_sids_update(struct interface *ifp, bool is_up)
+{
+	struct static_srv6_locator *locator;
+	struct static_srv6_sid *sid;
+	struct listnode *node;
+
+	if (!srv6_sids || !ifp)
+		return;
+
+	zlog_info("Interface %s %s. %s SIDs that depend on the interface", (is_up) ? "enabled" : "disabled", (is_up) ? "Removing" : "disabled", ifp->name);
+
+    /* iterate over the list of SRv6 SIDs and remove the SIDs that use this
+    * VRF from the zebra RIB */
+    for (ALL_LIST_ELEMENTS_RO(srv6_sids, node, sid)) {
+        if (strcmp(sid->attributes.vrf_name, ifp->name) == 0 ||
+                strncmp(ifp->name, "sr0", sizeof(ifp->name)) == 0 &&
+                (sid->behavior == STATIC_SRV6_SID_BEHAVIOR_END || sid->behavior == STATIC_SRV6_SID_BEHAVIOR_UN))
+            if (is_up)
+                static_zebra_srv6_sid_install(sid);
+            else
+                static_zebra_srv6_sid_uninstall(sid);
+    }
+}
+
+/*
+ * Allocate an SRv6 SID object and initialize the fields common to all the
+ * behaviors (i.e., SID address and behavor).
+ */
+struct static_srv6_sid *static_srv6_sid_alloc(struct prefix_ipv6 *addr)
+{
+	struct static_srv6_sid *sid = NULL;
+
+	sid = XCALLOC(MTYPE_STATIC_SRV6_SID, sizeof(struct static_srv6_sid));
+	sid->addr = *addr;
+
+	return sid;
+}
+
+void static_srv6_sid_free(struct static_srv6_sid *sid)
+{
+	XFREE(MTYPE_STATIC_SRV6_SID, sid);
+}
+
+struct static_srv6_locator *static_srv6_locator_lookup(const char *name)
+{
+	struct static_srv6_locator *locator;
+	struct listnode *node;
+
+	for (ALL_LIST_ELEMENTS_RO(srv6_locators, node, locator))
+		if (!strncmp(name, locator->name, SRV6_LOCNAME_SIZE))
+			return locator;
+	return NULL;
+}
+
+/*
+ * Look-up an SRv6 SID in the list of SRv6 SIDs.
+ */
+struct static_srv6_sid *static_srv6_sid_lookup(struct prefix_ipv6 *sid_addr)
+{
+	struct static_srv6_locator *locator;
+	struct static_srv6_sid *sid;
+	struct listnode *node1, *node2;
+
+	for (ALL_LIST_ELEMENTS_RO(srv6_locators, node1, locator))
+		for (ALL_LIST_ELEMENTS_RO(srv6_sids, node2, sid))
+			if (memcmp(&sid->addr, sid_addr, sizeof(struct prefix_ipv6)) == 0)
+				return sid;
+
+	return NULL;
+}
+
+struct static_srv6_locator *static_srv6_locator_alloc(const char *name)
+{
+	struct static_srv6_locator *locator = NULL;
+
+	locator = XCALLOC(MTYPE_STATIC_SRV6_LOCATOR, sizeof(struct static_srv6_locator));
+	strlcpy(locator->name, name, sizeof(locator->name));
+
+	return locator;
+}
+
+void static_srv6_locator_free(struct static_srv6_locator *locator)
+{
+	if (locator) {
+		XFREE(MTYPE_STATIC_SRV6_LOCATOR, locator);
+	}
+}
+
+void delete_static_srv6_locator(void *val)
+{
+	static_srv6_locator_free((struct static_srv6_locator *)val);
+}
+
+/*
+ * Remove an SRv6 SID from the zebra RIB (if it was previously installed) and
+ * release the memory previously allocated for the SID.
+ */
+void static_srv6_sid_del(struct static_srv6_sid *sid)
+{
+	// if (CHECK_FLAG(sid->flags, STATIC_FLAG_SRV6_SID_SENT_TO_ZEBRA))
+		static_zebra_release_srv6_sid(sid);
+		static_zebra_srv6_sid_uninstall(sid);
+
+	XFREE(MTYPE_STATIC_SRV6_SID, sid);
+}
+
+void delete_static_srv6_sid(void *val)
+{
+	static_srv6_sid_free((struct static_srv6_sid *)val);
+}
+
+/*
+ * Initialize SRv6 data structures.
+ */
+void static_srv6_init(void)
+{
+	srv6_locators = list_new();
+	srv6_sids = list_new();
+}
+
+/*
+ * Clean up all the SRv6 data structures.
+ */
+void static_srv6_cleanup(void)
+{
+	list_delete(&srv6_locators);
+	list_delete(&srv6_sids);
+}
\ No newline at end of file
diff --git a/staticd/static_srv6.h b/staticd/static_srv6.h
new file mode 100644
index 0000000000..9e9058b532
--- /dev/null
+++ b/staticd/static_srv6.h
@@ -0,0 +1,125 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * STATICd - Segment Routing over IPv6 (SRv6) header
+ */
+#ifndef __STATIC_SRV6_H__
+#define __STATIC_SRV6_H__
+
+#include "vrf.h"
+#include "srv6.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ * The order for below macros should be in sync with
+ * yang model typedef srv6-behavior
+ */
+enum static_srv6_sid_behavior_t {
+	STATIC_SRV6_SID_BEHAVIOR_UNSPEC = 0,
+	STATIC_SRV6_SID_BEHAVIOR_END = 1,
+	STATIC_SRV6_SID_BEHAVIOR_END_X = 2,
+	STATIC_SRV6_SID_BEHAVIOR_END_DT6 = 3,
+	STATIC_SRV6_SID_BEHAVIOR_END_DT4 = 4,
+	STATIC_SRV6_SID_BEHAVIOR_END_DT46 = 5,
+	STATIC_SRV6_SID_BEHAVIOR_UN = 6,
+	STATIC_SRV6_SID_BEHAVIOR_UA = 7,
+	STATIC_SRV6_SID_BEHAVIOR_UDT6 = 8,
+	STATIC_SRV6_SID_BEHAVIOR_UDT4 = 9,
+	STATIC_SRV6_SID_BEHAVIOR_UDT46 = 10,
+};
+
+/* Attributes for an SRv6 SID */
+struct static_srv6_sid_attributes {
+	/* VRF name */
+	char vrf_name[VRF_NAMSIZ];
+	char ifname[IFNAMSIZ];
+	struct in6_addr nh6;
+};
+
+/* Static SRv6 SID */
+struct static_srv6_sid {
+	/* SRv6 SID address */
+	struct prefix_ipv6 addr;
+	/* behavior bound to the SRv6 SID */
+	enum static_srv6_sid_behavior_t behavior;
+	/* SID attributes */
+	struct static_srv6_sid_attributes attributes;
+
+	/* SRv6 SID flags */
+	uint8_t flags;
+/* this SRv6 SID is valid and can be installed in the zebra RIB */
+#define STATIC_FLAG_SRV6_SID_VALID (1 << 0)
+/* this SRv6 SID has been installed in the zebra RIB */
+#define STATIC_FLAG_SRV6_SID_SENT_TO_ZEBRA (2 << 0)
+
+	char locator_name[SRV6_LOCNAME_SIZE];
+	struct static_srv6_locator *locator;
+};
+
+struct static_srv6_locator {
+	char name[SRV6_LOCNAME_SIZE];
+	struct prefix_ipv6 prefix;
+
+	/*
+	 * Bit length of SRv6 locator described in
+	 * draft-ietf-bess-srv6-services-05#section-3.2.1
+	 */
+	uint8_t block_bits_length;
+	uint8_t node_bits_length;
+	uint8_t function_bits_length;
+	uint8_t argument_bits_length;
+
+	uint8_t flags;
+#define SRV6_LOCATOR_USID (1 << 0) /* The SRv6 Locator is a uSID Locator */
+
+};
+
+/* List of SRv6 SIDs. */
+extern struct list *srv6_locators;
+extern struct list *srv6_sids;
+
+/* Allocate an SRv6 SID object and initialize its fields, SID address and
+ * behavor. */
+extern struct static_srv6_sid *
+static_srv6_sid_alloc(struct prefix_ipv6 *addr);
+extern void
+static_srv6_sid_free(struct static_srv6_sid *sid);
+/* Look-up an SRv6 SID in the list of SRv6 SIDs. */
+extern struct static_srv6_sid *
+static_srv6_sid_lookup(struct prefix_ipv6 *sid_addr);
+/* Remove an SRv6 SID from the zebra RIB (if it was previously installed) and
+ * release the memory previously allocated for the SID. */
+extern void static_srv6_sid_del(struct static_srv6_sid *sid);
+
+/* Convert SRv6 behavior to human-friendly string. */
+const char *
+static_srv6_sid_behavior2str(enum static_srv6_sid_behavior_t action);
+
+/* Initialize SRv6 data structures. */
+extern void static_srv6_init(void);
+/* Clean up all the SRv6 data structures. */
+extern void static_srv6_cleanup(void);
+
+/*
+ * When an interface is enabled in the kernel, go through all the static SRv6 SIDs in
+ * the system that use this interface and install/remove them in the zebra RIB.
+ *
+ * ifp   - The interface being enabled
+ * is_up - Whether the interface is up or down
+ */
+void static_ifp_srv6_sids_update(struct interface *ifp, bool is_up);
+
+struct static_srv6_locator *static_srv6_locator_alloc(const char *name);
+void static_srv6_locator_free(struct static_srv6_locator *locator);
+struct static_srv6_locator *static_srv6_locator_lookup(const char *name);
+
+void delete_static_srv6_sid(void *val);
+void delete_static_srv6_locator(void *val);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __STATIC_SRV6_H__ */
\ No newline at end of file
diff --git a/staticd/static_vrf.c b/staticd/static_vrf.c
index 710827a9ff..cf2c9eb73d 100644
--- a/staticd/static_vrf.c
+++ b/staticd/static_vrf.c
@@ -125,6 +125,7 @@ static int static_vrf_enable(struct vrf *vrf)
 {
 	static_zebra_vrf_register(vrf);
 	static_fixup_vrf_ids(vrf);
+
 	return 0;
 }
 
@@ -132,6 +133,7 @@ static int static_vrf_disable(struct vrf *vrf)
 {
 	static_cleanup_vrf_ids(vrf);
 	static_zebra_vrf_unregister(vrf);
+
 	return 0;
 }
 
diff --git a/staticd/static_vty.c b/staticd/static_vty.c
index 07b8bc3d28..db112b6c0f 100644
--- a/staticd/static_vty.c
+++ b/staticd/static_vty.c
@@ -27,6 +27,8 @@
 #include "static_debug.h"
 #include "staticd/static_vty_clippy.c"
 #include "static_nb.h"
+#include "static_srv6.h"
+#include "static_zebra.h"
 
 #define STATICD_STR "Static route daemon\n"
 
@@ -1201,6 +1203,183 @@ DEFPY_YANG(ipv6_route_vrf, ipv6_route_vrf_cmd,
 	return static_route_nb_run(vty, &args);
 }
 
+DEFUN_NOSH (static_segment_routing, static_segment_routing_cmd,
+      "segment-routing",
+      "Segment Routing\n")
+{
+	VTY_PUSH_CONTEXT_NULL(SEGMENT_ROUTING_NODE);
+	return CMD_SUCCESS;
+}
+
+DEFUN_NOSH (static_srv6, static_srv6_cmd,
+      "srv6",
+      "Segment Routing SRv6\n")
+{
+	VTY_PUSH_CONTEXT_NULL(SRV6_NODE);
+	return CMD_SUCCESS;
+}
+
+DEFUN_YANG_NOSH (no_static_srv6, no_static_srv6_cmd,
+      "no srv6",
+      NO_STR
+      "Segment Routing SRv6\n")
+{
+	char xpath[XPATH_MAXLEN];
+
+	snprintf(xpath, sizeof(xpath), "/frr-routing:routing/control-plane-protocols/control-plane-protocol[type='%s'][name='%s'][vrf='%s']/frr-staticd:staticd/segment-routing/srv6",
+		 "frr-staticd:staticd", "staticd", VRF_DEFAULT_NAME);
+
+	nb_cli_enqueue_change(vty, xpath, NB_OP_DESTROY, NULL);
+
+	return nb_cli_apply_changes(vty, "%s", xpath);
+}
+
+DEFUN_NOSH (static_srv6_sids, static_srv6_sids_cmd,
+      "static-sids",
+      "Segment Routing SRv6 SIDs\n")
+{
+	VTY_PUSH_CONTEXT_NULL(SRV6_SIDS_NODE);
+	return CMD_SUCCESS;
+}
+
+
+static const char *seg6local_action2yang(uint32_t action)
+{
+	switch (action) {
+	case STATIC_SRV6_SID_BEHAVIOR_UN:
+		return "un";
+	case STATIC_SRV6_SID_BEHAVIOR_UA:
+		return "ua";
+	case STATIC_SRV6_SID_BEHAVIOR_UDT6:
+		return "udt6";
+	case STATIC_SRV6_SID_BEHAVIOR_UDT4:
+		return "udt4";
+	case STATIC_SRV6_SID_BEHAVIOR_UDT46:
+		return "udt46";
+	}
+	return "unspec";
+}
+
+DEFPY_YANG(srv6_sid, srv6_sid_cmd,
+      "sid X:X::X:X/M locator NAME$locator_name behavior <uN | uDT6 vrf VIEWVRFNAME | uDT4 vrf VIEWVRFNAME | uDT46 vrf VIEWVRFNAME>",
+	  "Configure SRv6 SID\n"
+      "Specify SRv6 SID\n"
+	  "Locator name\n"
+      "Specify Locator name\n"
+      "Specify SRv6 SID behavior\n"
+      "Apply the code to a uN SID\n"
+      "Apply the code to an uDT6 SID\n"
+      "Configure VRF name\n"
+      "Specify VRF name\n"
+      "Apply the code to an uDT4 SID\n"
+      "Configure VRF name\n"
+      "Specify VRF name\n"
+      "Apply the code to an uDT46 SID\n"
+      "Configure VRF name\n"
+      "Specify VRF name\n")
+{
+	enum static_srv6_sid_behavior_t behavior = STATIC_SRV6_SID_BEHAVIOR_UNSPEC;
+	int idx = 0;
+	const char *vrf_name = NULL;
+	char xpath_sid[XPATH_MAXLEN];
+	char xpath_behavior[XPATH_MAXLEN];
+	char xpath_vrf_name[XPATH_MAXLEN];
+	char xpath_locator_name[XPATH_MAXLEN];
+
+	if (argv_find(argv, argc, "uN", &idx)) {
+		behavior = STATIC_SRV6_SID_BEHAVIOR_UN;
+	} else if (argv_find(argv, argc, "uDT6", &idx)) {
+		behavior = STATIC_SRV6_SID_BEHAVIOR_UDT6;
+		vrf_name = argv[idx + 2]->arg;
+	} else if (argv_find(argv, argc, "uDT4", &idx)) {
+		behavior = STATIC_SRV6_SID_BEHAVIOR_UDT4;
+		vrf_name = argv[idx + 2]->arg;
+	} else if (argv_find(argv, argc, "uDT46", &idx)) {
+		behavior = STATIC_SRV6_SID_BEHAVIOR_UDT46;
+		vrf_name = argv[idx + 2]->arg;
+	}
+
+	snprintf(xpath_sid, sizeof(xpath_sid), "/frr-routing:routing/control-plane-protocols/control-plane-protocol[type='%s'][name='%s'][vrf='%s']/frr-staticd:staticd/segment-routing/srv6/local-sids/sid[sid='%s']",
+		 "frr-staticd:staticd", "staticd", VRF_DEFAULT_NAME, sid_str);
+
+	snprintf(xpath_behavior, sizeof(xpath_behavior), "/frr-routing:routing/control-plane-protocols/control-plane-protocol[type='%s'][name='%s'][vrf='%s']/frr-staticd:staticd/segment-routing/srv6/local-sids/sid[sid='%s']/behavior",
+		 "frr-staticd:staticd", "staticd", VRF_DEFAULT_NAME, sid_str);
+
+	nb_cli_enqueue_change(vty, xpath_sid,
+					NB_OP_CREATE, sid_str);
+
+	nb_cli_enqueue_change(vty, xpath_behavior,
+					NB_OP_MODIFY, seg6local_action2yang(behavior));
+
+	if (vrf_name) {
+		snprintf(xpath_vrf_name, sizeof(xpath_vrf_name), "/frr-routing:routing/control-plane-protocols/control-plane-protocol[type='%s'][name='%s'][vrf='%s']/frr-staticd:staticd/segment-routing/srv6/local-sids/sid[sid='%s']/vrf-name",
+			"frr-staticd:staticd", "staticd", VRF_DEFAULT_NAME, sid_str);
+
+		nb_cli_enqueue_change(vty, xpath_vrf_name,
+						NB_OP_MODIFY, vrf_name);
+	}
+
+	if (locator_name) {
+		snprintf(xpath_locator_name, sizeof(xpath_locator_name), "/frr-routing:routing/control-plane-protocols/control-plane-protocol[type='%s'][name='%s'][vrf='%s']/frr-staticd:staticd/segment-routing/srv6/local-sids/sid[sid='%s']/locator-name",
+			"frr-staticd:staticd", "staticd", VRF_DEFAULT_NAME, sid_str);
+
+		nb_cli_enqueue_change(vty, xpath_locator_name,
+						NB_OP_MODIFY, locator_name);
+	}
+
+	return nb_cli_apply_changes(vty, "%s", xpath_sid);
+}
+
+DEFPY_YANG(no_srv6_sid, no_srv6_sid_cmd,
+      "no sid X:X::X:X/M [locator NAME$locator_name] [behavior <uN | uDT6 vrf VIEWVRFNAME | uDT4 vrf VIEWVRFNAME | uDT46 vrf VIEWVRFNAME>]",
+      NO_STR
+	  "Configure SRv6 SID\n"
+      "Specify SRv6 SID\n"
+	  "Locator name\n"
+      "Specify Locator name\n"
+      "Specify SRv6 SID behavior\n"
+      "Apply the code to a uN SID\n"
+      "Apply the code to an uDT6 SID\n"
+      "Configure VRF name\n"
+      "Specify VRF name\n"
+      "Apply the code to an uDT4 SID\n"
+      "Configure VRF name\n"
+      "Specify VRF name\n"
+      "Apply the code to an uDT46 SID\n"
+      "Configure VRF name\n"
+      "Specify VRF name\n")
+{
+	char xpath[XPATH_MAXLEN + 37];
+
+	snprintf(xpath, sizeof(xpath), "/frr-routing:routing/control-plane-protocols/control-plane-protocol[type='%s'][name='%s'][vrf='%s']/frr-staticd:staticd/segment-routing/srv6/local-sids/sid[sid='%s']",
+		 "frr-staticd:staticd", "staticd", VRF_DEFAULT_NAME, sid_str);
+
+	nb_cli_enqueue_change(vty, xpath, NB_OP_DESTROY, NULL);
+
+	return nb_cli_apply_changes(vty, NULL);
+}
+
+static struct cmd_node sr_node = {
+	.name = "sr",
+	.node = SEGMENT_ROUTING_NODE,
+	.parent_node = CONFIG_NODE,
+	.prompt = "%s(config-sr)# ",
+};
+
+static struct cmd_node srv6_node = {
+	.name = "srv6",
+	.node = SRV6_NODE,
+	.parent_node = SEGMENT_ROUTING_NODE,
+	.prompt = "%s(config-srv6)# ",
+};
+
+static struct cmd_node srv6_sids_node = {
+	.name = "srv6-sids",
+	.node = SRV6_SIDS_NODE,
+	.parent_node = SRV6_NODE,
+	.prompt = "%s(config-srv6-sids)# ",
+};
+
 #ifdef INCLUDE_MGMTD_CMDDEFS_ONLY
 
 static void static_cli_show(struct vty *vty, const struct lyd_node *dnode,
@@ -1545,6 +1724,104 @@ static int static_path_list_cli_cmp(const struct lyd_node *dnode1,
 	return (int)distance1 - (int)distance2;
 }
 
+static void static_segment_routing_cli_show(struct vty *vty, const struct lyd_node *dnode,
+			    bool show_defaults)
+{
+	vty_out(vty, "segment-routing\n");
+}
+
+static void static_segment_routing_cli_show_end(struct vty *vty, const struct lyd_node *dnode)
+{
+	vty_out(vty, "exit\n");
+	vty_out(vty, "!\n");
+}
+
+static void static_srv6_cli_show(struct vty *vty, const struct lyd_node *dnode,
+			    bool show_defaults)
+{
+	vty_out(vty, " srv6\n");
+}
+
+static void static_srv6_cli_show_end(struct vty *vty, const struct lyd_node *dnode)
+{
+	vty_out(vty, " exit\n");
+	vty_out(vty, " !\n");
+}
+
+static void static_sids_cli_show(struct vty *vty, const struct lyd_node *dnode,
+			    bool show_defaults)
+{
+	vty_out(vty, "  static-sids\n");
+}
+
+static void static_sids_cli_show_end(struct vty *vty, const struct lyd_node *dnode)
+{
+	vty_out(vty, "  exit\n");
+	vty_out(vty, "  !\n");
+}
+
+static void srv6_sid_cli_show(struct vty *vty, const struct lyd_node *sid,
+			     bool show_defaults)
+{
+	enum static_srv6_sid_behavior_t srv6_behavior;
+	struct prefix_ipv6 sid_value;
+
+	yang_dnode_get_ipv6p(&sid_value, sid, "sid");
+
+	vty_out(vty, "   sid %pFX", &sid_value);
+	if (yang_dnode_exists(sid, "locator-name"))
+		vty_out(vty, " locator %s", yang_dnode_get_string(sid, "locator-name"));
+
+	srv6_behavior = yang_dnode_get_enum(sid, "behavior");
+	switch(srv6_behavior) {
+		case STATIC_SRV6_SID_BEHAVIOR_END:
+			vty_out(vty, " behavior End");
+			break;
+		case STATIC_SRV6_SID_BEHAVIOR_END_X:
+			vty_out(vty, " behavior End.X");
+			break;
+		case STATIC_SRV6_SID_BEHAVIOR_END_DT6:
+			vty_out(vty, " behavior End.DT6");
+			break;
+		case STATIC_SRV6_SID_BEHAVIOR_END_DT4:
+			vty_out(vty, " behavior End.DT4");
+			break;
+		case STATIC_SRV6_SID_BEHAVIOR_END_DT46:
+			vty_out(vty, " behavior End.DT46");
+			break;
+		case STATIC_SRV6_SID_BEHAVIOR_UN:
+			vty_out(vty, " behavior uN");
+			break;
+		case STATIC_SRV6_SID_BEHAVIOR_UA:
+			vty_out(vty, " behavior uA");
+			break;
+		case STATIC_SRV6_SID_BEHAVIOR_UDT6:
+			vty_out(vty, " behavior uDT6");
+			break;
+		case STATIC_SRV6_SID_BEHAVIOR_UDT4:
+			vty_out(vty, " behavior uDT4");
+			break;
+		case STATIC_SRV6_SID_BEHAVIOR_UDT46:
+			vty_out(vty, " behavior uDT46");
+			break;
+		case STATIC_SRV6_SID_BEHAVIOR_UNSPEC:
+			vty_out(vty, " behavior unknown");
+			break;
+	}
+
+	if (yang_dnode_exists(sid, "vrf-name"))
+		vty_out(vty, " vrf %s", yang_dnode_get_string(sid, "vrf-name"));
+
+	vty_out(vty, "\n");
+}
+
+static void static_srv6_sid_cli_show(struct vty *vty,
+					const struct lyd_node *dnode,
+					bool show_defaults)
+{
+	srv6_sid_cli_show(vty, dnode, show_defaults);
+}
+
 const struct frr_yang_module_info frr_staticd_cli_info = {
 	.name = "frr-staticd",
 	.ignore_cfg_cbs = true,
@@ -1594,6 +1871,33 @@ const struct frr_yang_module_info frr_staticd_cli_info = {
 				.cli_cmp = static_nexthop_cli_cmp,
 			}
 		},
+		{
+			.xpath = "/frr-routing:routing/control-plane-protocols/control-plane-protocol/frr-staticd:staticd/segment-routing",
+			.cbs = {
+				.cli_show = static_segment_routing_cli_show,
+				.cli_show_end = static_segment_routing_cli_show_end,
+			}
+		},
+		{
+			.xpath = "/frr-routing:routing/control-plane-protocols/control-plane-protocol/frr-staticd:staticd/segment-routing/srv6",
+			.cbs = {
+				.cli_show = static_srv6_cli_show,
+				.cli_show_end = static_srv6_cli_show_end,
+			}
+		},
+		{
+			.xpath = "/frr-routing:routing/control-plane-protocols/control-plane-protocol/frr-staticd:staticd/segment-routing/srv6/local-sids",
+			.cbs = {
+				.cli_show = static_sids_cli_show,
+				.cli_show_end = static_sids_cli_show_end,
+			}
+		},
+		{
+			.xpath = "/frr-routing:routing/control-plane-protocols/control-plane-protocol/frr-staticd:staticd/segment-routing/srv6/local-sids/sid",
+			.cbs = {
+				.cli_show = static_srv6_sid_cli_show,
+			}
+		},
 		{
 			.xpath = NULL,
 		},
@@ -1653,6 +1957,7 @@ void static_vty_init(void)
 	install_element(CONFIG_NODE, &debug_staticd_cmd);
 	install_element(ENABLE_NODE, &show_debugging_static_cmd);
 	install_element(ENABLE_NODE, &staticd_show_bfd_routes_cmd);
+
 #else /* else INCLUDE_MGMTD_CMDDEFS_ONLY */
 	install_element(CONFIG_NODE, &ip_mroute_dist_cmd);
 
@@ -1669,6 +1974,21 @@ void static_vty_init(void)
 	install_element(VRF_NODE, &ipv6_route_address_interface_vrf_cmd);
 	install_element(CONFIG_NODE, &ipv6_route_cmd);
 	install_element(VRF_NODE, &ipv6_route_vrf_cmd);
+
+	install_node(&sr_node);
+	install_node(&srv6_node);
+	install_node(&srv6_sids_node);
+	install_default(SEGMENT_ROUTING_NODE);
+	install_default(SRV6_NODE);
+	install_default(SRV6_SIDS_NODE);
+	
+	install_element(CONFIG_NODE, &static_segment_routing_cmd);
+	install_element(SEGMENT_ROUTING_NODE, &static_srv6_cmd);
+	install_element(SEGMENT_ROUTING_NODE, &no_static_srv6_cmd);
+	install_element(SRV6_NODE, &static_srv6_sids_cmd);
+	install_element(SRV6_SIDS_NODE, &srv6_sid_cmd);
+	install_element(SRV6_SIDS_NODE, &no_srv6_sid_cmd);
+
 #endif /* ifndef INCLUDE_MGMTD_CMDDEFS_ONLY */
 
 #ifndef INCLUDE_MGMTD_CMDDEFS_ONLY
diff --git a/staticd/static_zebra.c b/staticd/static_zebra.c
index d76befc131..f86fd3b48a 100644
--- a/staticd/static_zebra.c
+++ b/staticd/static_zebra.c
@@ -30,6 +30,9 @@
 #include "static_nht.h"
 #include "static_vty.h"
 #include "static_debug.h"
+#include "zclient.h"
+#include "static_srv6.h"
+#include "lib_errors.h"
 
 DEFINE_MTYPE_STATIC(STATIC, STATIC_NHT_DATA, "Static Nexthop tracking data");
 PREDECL_HASH(static_nht_hash);
@@ -113,6 +116,8 @@ static int static_ifp_up(struct interface *ifp)
 {
 	static_ifindex_update(ifp, true);
 
+	static_ifp_srv6_sids_update(ifp, true);
+
 	return 0;
 }
 
@@ -120,6 +125,8 @@ static int static_ifp_down(struct interface *ifp)
 {
 	static_ifindex_update(ifp, false);
 
+	static_ifp_srv6_sids_update(ifp, false);
+
 	return 0;
 }
 
@@ -529,10 +536,701 @@ extern void static_zebra_route_add(struct static_path *pn, bool install)
 			   zclient, &api);
 }
 
+/**
+ * Send SRv6 SID to ZEBRA for installation or deletion.
+ *
+ * @param cmd		ZEBRA_ROUTE_ADD or ZEBRA_ROUTE_DELETE
+ * @param sid		SRv6 SID to install or delete
+ * @param prefixlen	Prefix length
+ * @param oif		Outgoing interface
+ * @param action	SID action
+ * @param context	SID context
+ */
+static void static_zebra_send_localsid(int cmd, const struct in6_addr *sid,
+				     uint16_t prefixlen, ifindex_t oif,
+				     enum seg6local_action_t action,
+				     const struct seg6local_context *context)
+{
+	struct prefix_ipv6 p = {};
+	struct zapi_route api = {};
+	struct zapi_nexthop *znh;
+
+	if (cmd != ZEBRA_ROUTE_ADD && cmd != ZEBRA_ROUTE_DELETE) {
+		flog_warn(EC_LIB_DEVELOPMENT, "%s: wrong ZEBRA command",
+			  __func__);
+		return;
+	}
+
+	if (prefixlen > IPV6_MAX_BITLEN) {
+		flog_warn(EC_LIB_DEVELOPMENT, "%s: wrong prefixlen %u",
+			  __func__, prefixlen);
+		return;
+	}
+
+	zlog_info("  |- %s SRv6 SID %pI6 behavior %s",
+		 cmd == ZEBRA_ROUTE_ADD ? "Add" : "Delete", sid,
+		 seg6local_action2str(action));
+
+	p.family = AF_INET6;
+	p.prefixlen = prefixlen;
+	p.prefix = *sid;
+
+	api.vrf_id = VRF_DEFAULT;
+	api.type = ZEBRA_ROUTE_STATIC;
+	api.instance = 0;
+	api.safi = SAFI_UNICAST;
+	memcpy(&api.prefix, &p, sizeof(p));
+
+	if (cmd == ZEBRA_ROUTE_DELETE)
+		return (void)zclient_route_send(ZEBRA_ROUTE_DELETE, zclient,
+						&api);
+
+	SET_FLAG(api.flags, ZEBRA_FLAG_ALLOW_RECURSION);
+	SET_FLAG(api.message, ZAPI_MESSAGE_NEXTHOP);
+
+	znh = &api.nexthops[0];
+
+	memset(znh, 0, sizeof(*znh));
+
+	znh->type = NEXTHOP_TYPE_IFINDEX;
+	znh->ifindex = oif;
+	SET_FLAG(znh->flags, ZAPI_NEXTHOP_FLAG_SEG6LOCAL);
+	znh->seg6local_action = action;
+	memcpy(&znh->seg6local_ctx, context, sizeof(struct seg6local_context));
+
+	api.nexthop_num = 1;
+
+	zclient_route_send(ZEBRA_ROUTE_ADD, zclient, &api);
+}
+
+/**
+ * Install SRv6 SID in the forwarding plane through Zebra.
+ *
+ * @param sid		SRv6 SID
+ */
+void static_zebra_srv6_sid_install(struct static_srv6_sid *sid)
+{
+	enum seg6local_action_t action = ZEBRA_SEG6_LOCAL_ACTION_UNSPEC;
+	struct seg6local_context ctx = {};
+	struct interface *ifp = NULL;
+	struct vrf *vrf;
+	struct prefix_ipv6 sid_block = {};
+	struct prefix_ipv6 locator_block = {};
+	struct prefix_ipv6 sid_locator = {};
+
+	if (!sid)
+		return;
+
+	zlog_info("setting SRv6 SID %pFX",
+		 &sid->addr);
+
+	if (!sid->locator) {
+		zlog_err("Failed to install SID %pFX: missing locator information", &sid->addr);
+		return;
+	}
+
+	switch (sid->behavior) {
+	case STATIC_SRV6_SID_BEHAVIOR_END:
+		action = ZEBRA_SEG6_LOCAL_ACTION_END;
+		break;
+	case STATIC_SRV6_SID_BEHAVIOR_UN:
+		action = ZEBRA_SEG6_LOCAL_ACTION_END;
+		SET_SRV6_FLV_OP(ctx.flv.flv_ops,
+				ZEBRA_SEG6_LOCAL_FLV_OP_NEXT_CSID);
+		ctx.flv.lcblock_len = sid->locator->block_bits_length;
+		ctx.flv.lcnode_func_len = sid->locator->node_bits_length;
+		break;
+	case STATIC_SRV6_SID_BEHAVIOR_END_DT6:
+	case STATIC_SRV6_SID_BEHAVIOR_UDT6:
+		action = ZEBRA_SEG6_LOCAL_ACTION_END_DT6;
+		vrf = vrf_lookup_by_name(sid->attributes.vrf_name);
+		if (!vrf || !CHECK_FLAG(vrf->status, VRF_ACTIVE)) {
+			zlog_warn("Inactive vrf");
+			return;
+		}
+		ctx.table = vrf->data.l.table_id;
+		ifp = if_get_vrf_loopback(vrf->vrf_id);
+		if (!ifp) {
+			zlog_warn("failed to get interface");
+			return;
+		}
+		break;
+	case STATIC_SRV6_SID_BEHAVIOR_END_DT4:
+	case STATIC_SRV6_SID_BEHAVIOR_UDT4:
+		action = ZEBRA_SEG6_LOCAL_ACTION_END_DT4;
+		vrf = vrf_lookup_by_name(sid->attributes.vrf_name);
+		if (!vrf || !CHECK_FLAG(vrf->status, VRF_ACTIVE)) {
+			zlog_warn("Inactive vrf");
+			return;
+		}
+		ctx.table = vrf->data.l.table_id;
+		ifp = if_get_vrf_loopback(vrf->vrf_id);
+		if (!ifp) {
+			zlog_warn("failed to get interface");
+			return;
+		}
+		break;
+	case STATIC_SRV6_SID_BEHAVIOR_END_DT46:
+	case STATIC_SRV6_SID_BEHAVIOR_UDT46:
+		action = ZEBRA_SEG6_LOCAL_ACTION_END_DT46;
+		vrf = vrf_lookup_by_name(sid->attributes.vrf_name);
+		if (!vrf || !CHECK_FLAG(vrf->status, VRF_ACTIVE)) {
+			zlog_warn("Inactive vrf");
+			return;
+		}
+		ctx.table = vrf->data.l.table_id;
+		ifp = if_get_vrf_loopback(vrf->vrf_id);
+		if (!ifp) {
+			zlog_warn("failed to get interface");
+			return;
+		}
+		break;
+	case STATIC_SRV6_SID_BEHAVIOR_UNSPEC:
+		zlog_warn("unsupported behavior: %u", sid->behavior);
+		break;
+	}
+
+	ctx.block_len = 0;
+	ctx.node_len = 0;
+	ctx.function_len = 0;
+	ctx.argument_len = 0;
+
+	sid_block = sid->addr;
+	sid_block.prefixlen = sid->locator->block_bits_length;
+	apply_mask(&sid_block);
+
+	locator_block = sid->locator->prefix;
+	locator_block.prefixlen = sid->locator->block_bits_length;
+	apply_mask(&locator_block);
+
+	if (prefix_same(&sid_block, &locator_block))
+		ctx.block_len = sid->locator->block_bits_length;
+	else {
+		zlog_warn("SID block %pFX does not match locator block %pFX", &sid_block, &locator_block);
+		return;
+	}
+
+	sid_locator = sid->addr;
+	sid_locator.prefixlen = sid->locator->block_bits_length + sid->locator->node_bits_length;
+	apply_mask(&sid_locator);
+
+	if (prefix_same(&sid_locator, &sid->locator->prefix))
+		ctx.node_len = sid->locator->node_bits_length;
+	else {
+		zlog_warn("SID locator %pFX does not match the specified locator %pFX", &sid_locator, &sid->locator->prefix);
+		return;
+	}
+
+	ctx.function_len = sid->addr.prefixlen - (ctx.block_len + ctx.node_len);
+
+	/* Attach the SID to the SRv6 interface */
+	if (!ifp) {
+		ifp = if_lookup_by_name("sr0", VRF_DEFAULT);
+		if (!ifp) {
+			zlog_warn(
+				"Failed to install SRv6 SID %pFX: %s interface not found",
+				&sid->addr, "sr0");
+			return;
+		}
+	}
+
+	/* Send the SID to zebra */
+	static_zebra_send_localsid(ZEBRA_ROUTE_ADD, &sid->addr.prefix, sid->addr.prefixlen,
+				 ifp->ifindex, action, &ctx);
+}
+
+void static_zebra_srv6_sid_uninstall(struct static_srv6_sid *sid)
+{
+	enum seg6local_action_t action = ZEBRA_SEG6_LOCAL_ACTION_UNSPEC;
+	struct interface *ifp = NULL;
+	struct seg6local_context ctx = {};
+	struct vrf *vrf;
+	struct prefix_ipv6 sid_block = {};
+	struct prefix_ipv6 locator_block = {};
+	struct prefix_ipv6 sid_locator = {};
+
+	if (!sid)
+		return;
+
+	zlog_info("delete SID %pFX", &sid->addr);
+
+	if (!sid->locator) {
+		zlog_err("Failed to uninstall SID %pFX: missing locator information", &sid->addr);
+		return;
+	}
+
+	switch (sid->behavior) {
+	case STATIC_SRV6_SID_BEHAVIOR_END:
+	case STATIC_SRV6_SID_BEHAVIOR_UN:
+		break;
+	case STATIC_SRV6_SID_BEHAVIOR_END_DT6:
+	case STATIC_SRV6_SID_BEHAVIOR_UDT6:
+		vrf = vrf_lookup_by_name(sid->attributes.vrf_name);
+		if (!vrf || !CHECK_FLAG(vrf->status, VRF_ACTIVE)) {
+			zlog_warn("Inactive vrf");
+			return;
+		}
+		ifp = if_get_vrf_loopback(vrf->vrf_id);
+		if (!ifp) {
+			zlog_warn("failed to get interface");
+			return;
+		}
+		break;
+	case STATIC_SRV6_SID_BEHAVIOR_END_DT4:
+	case STATIC_SRV6_SID_BEHAVIOR_UDT4:
+		vrf = vrf_lookup_by_name(sid->attributes.vrf_name);
+		if (!vrf || !CHECK_FLAG(vrf->status, VRF_ACTIVE)) {
+			zlog_warn("Inactive vrf");
+			return;
+		}
+		ifp = if_get_vrf_loopback(vrf->vrf_id);
+		if (!ifp) {
+			zlog_warn("failed to get interface");
+			return;
+		}
+		break;
+	case STATIC_SRV6_SID_BEHAVIOR_END_DT46:
+	case STATIC_SRV6_SID_BEHAVIOR_UDT46:
+		vrf = vrf_lookup_by_name(sid->attributes.vrf_name);
+		if (!vrf || !CHECK_FLAG(vrf->status, VRF_ACTIVE)) {
+			zlog_warn("Inactive vrf");
+			return;
+		}
+		ifp = if_get_vrf_loopback(vrf->vrf_id);
+		if (!ifp) {
+			zlog_warn("failed to get interface");
+			return;
+		}
+		break;
+	case STATIC_SRV6_SID_BEHAVIOR_UNSPEC:
+		zlog_warn("unsupported behavior: %u", sid->behavior);
+		break;
+	}
+
+	/* The SID is attached to the SRv6 interface */
+	if (!ifp) {
+		ifp = if_lookup_by_name("sr0", VRF_DEFAULT);
+		if (!ifp) {
+			zlog_warn("%s interface not found: nothing to uninstall",
+				"sr0");
+			return;
+		}
+	}
+
+	ctx.block_len = 0;
+	ctx.node_len = 0;
+	ctx.function_len = 0;
+	ctx.argument_len = 0;
+
+	sid_block = sid->addr;
+	sid_block.prefixlen = sid->locator->block_bits_length;
+	apply_mask(&sid_block);
+
+	locator_block = sid->locator->prefix;
+	locator_block.prefixlen = sid->locator->block_bits_length;
+	apply_mask(&locator_block);
+
+	if (prefix_same(&sid_block, &locator_block))
+		ctx.block_len = sid->locator->block_bits_length;
+	else {
+		zlog_warn("SID block %pFX does not match locator block %pFX", &sid_block, &locator_block);
+		return;
+	}
+
+	sid_locator = sid->addr;
+	sid_locator.prefixlen = sid->locator->block_bits_length + sid->locator->node_bits_length;
+	apply_mask(&sid_locator);
+
+	if (prefix_same(&sid_locator, &sid->locator->prefix))
+		ctx.node_len = sid->locator->node_bits_length;
+	else {
+		zlog_warn("SID locator %pFX does not match the specified locator %pFX", &sid_locator, &sid->locator->prefix);
+		return;
+	}
+
+	ctx.function_len = sid->addr.prefixlen - (ctx.block_len + ctx.node_len);
+
+	zlog_info("delete SID %pFX",
+		 &sid->addr);
+
+	static_zebra_send_localsid(ZEBRA_ROUTE_DELETE, &sid->addr.prefix, sid->addr.prefixlen,
+				 ifp->ifindex, action, &ctx);
+}
+
+extern void static_zebra_request_srv6_sid(struct static_srv6_sid *sid)
+{
+	struct srv6_sid_ctx ctx = {};
+	int ret = 0;
+	struct vrf *vrf;
+
+	if (!sid)
+		return;
+
+	/* convert `static_srv6_sid_behavior_t` to `seg6local_action_t` */
+	switch (sid->behavior) {
+	case STATIC_SRV6_SID_BEHAVIOR_UNSPEC:
+		ctx.behavior = ZEBRA_SEG6_LOCAL_ACTION_UNSPEC;
+		break;
+	case STATIC_SRV6_SID_BEHAVIOR_END:
+	case STATIC_SRV6_SID_BEHAVIOR_UN:
+		ctx.behavior = ZEBRA_SEG6_LOCAL_ACTION_END;
+		break;
+	case STATIC_SRV6_SID_BEHAVIOR_END_DT6:
+	case STATIC_SRV6_SID_BEHAVIOR_UDT6:
+		ctx.behavior = ZEBRA_SEG6_LOCAL_ACTION_END_DT6;
+		/* process SRv6 SID attributes */
+		/* generate table ID from the VRF name, if configured */
+		if (sid->attributes.vrf_name[0] != '\0') {
+			vrf = vrf_lookup_by_name(sid->attributes.vrf_name);
+			if (!vrf || !CHECK_FLAG(vrf->status, VRF_ACTIVE))
+				return;
+			ctx.vrf_id = vrf->vrf_id;
+		}
+
+		break;
+	case STATIC_SRV6_SID_BEHAVIOR_END_DT4:
+	case STATIC_SRV6_SID_BEHAVIOR_UDT4:
+		ctx.behavior = ZEBRA_SEG6_LOCAL_ACTION_END_DT4;
+		/* process SRv6 SID attributes */
+		/* generate table ID from the VRF name, if configured */
+		if (sid->attributes.vrf_name[0] != '\0') {
+			vrf = vrf_lookup_by_name(sid->attributes.vrf_name);
+			if (!vrf || !CHECK_FLAG(vrf->status, VRF_ACTIVE))
+				return;
+			ctx.vrf_id = vrf->vrf_id;
+		}
+
+		break;
+	case STATIC_SRV6_SID_BEHAVIOR_END_DT46:
+	case STATIC_SRV6_SID_BEHAVIOR_UDT46:
+		ctx.behavior = ZEBRA_SEG6_LOCAL_ACTION_END_DT46;
+		/* process SRv6 SID attributes */
+		/* generate table ID from the VRF name, if configured */
+		if (sid->attributes.vrf_name[0] != '\0') {
+			vrf = vrf_lookup_by_name(sid->attributes.vrf_name);
+			if (!vrf || !CHECK_FLAG(vrf->status, VRF_ACTIVE))
+				return;
+			ctx.vrf_id = vrf->vrf_id;
+		}
+
+		break;
+	}
+
+	zlog_info("calling srv6_manager_get_sid");
+
+	/* install the SRv6 SID in the zebra RIB */
+	ret = srv6_manager_get_sid(zclient, &ctx, &sid->addr.prefix, sid->locator->name, NULL);
+	if (ret < 0) {
+		zlog_warn("%s: error getting SRv6 SID!", __func__);
+	}
+}
+
+extern void static_zebra_release_srv6_sid(struct static_srv6_sid *sid)
+{
+	struct srv6_sid_ctx ctx = {};
+	struct vrf *vrf;
+	int ret = 0;
+
+	if (!sid)
+		return;
+
+	/* convert `static_srv6_sid_behavior_t` to `seg6local_action_t` */
+	switch (sid->behavior) {
+	case STATIC_SRV6_SID_BEHAVIOR_UNSPEC:
+		ctx.behavior = ZEBRA_SEG6_LOCAL_ACTION_UNSPEC;
+		break;
+	case STATIC_SRV6_SID_BEHAVIOR_END:
+	case STATIC_SRV6_SID_BEHAVIOR_UN:
+		ctx.behavior = ZEBRA_SEG6_LOCAL_ACTION_END;
+		break;
+	case STATIC_SRV6_SID_BEHAVIOR_END_DT6:
+	case STATIC_SRV6_SID_BEHAVIOR_UDT6:
+		ctx.behavior = ZEBRA_SEG6_LOCAL_ACTION_END_DT6;
+		/* process SRv6 SID attributes */
+		/* generate table ID from the VRF name, if configured */
+		if (sid->attributes.vrf_name[0] != '\0') {
+			vrf = vrf_lookup_by_name(sid->attributes.vrf_name);
+			if (!vrf || !CHECK_FLAG(vrf->status, VRF_ACTIVE))
+				return;
+			ctx.vrf_id = vrf->vrf_id;
+		}
+
+		break;
+	case STATIC_SRV6_SID_BEHAVIOR_END_DT4:
+	case STATIC_SRV6_SID_BEHAVIOR_UDT4:
+		ctx.behavior = ZEBRA_SEG6_LOCAL_ACTION_END_DT4;
+		/* process SRv6 SID attributes */
+		/* generate table ID from the VRF name, if configured */
+		if (sid->attributes.vrf_name[0] != '\0') {
+			vrf = vrf_lookup_by_name(sid->attributes.vrf_name);
+			if (!vrf || !CHECK_FLAG(vrf->status, VRF_ACTIVE))
+				return;
+			ctx.vrf_id = vrf->vrf_id;
+		}
+
+		break;
+	case STATIC_SRV6_SID_BEHAVIOR_END_DT46:
+	case STATIC_SRV6_SID_BEHAVIOR_UDT46:
+		ctx.behavior = ZEBRA_SEG6_LOCAL_ACTION_END_DT46;
+		/* process SRv6 SID attributes */
+		/* generate table ID from the VRF name, if configured */
+		if (sid->attributes.vrf_name[0] != '\0') {
+			vrf = vrf_lookup_by_name(sid->attributes.vrf_name);
+			if (!vrf || !CHECK_FLAG(vrf->status, VRF_ACTIVE))
+				return;
+			ctx.vrf_id = vrf->vrf_id;
+		}
+
+		break;
+	}
+
+	/* remove the SRv6 SID from the zebra RIB */
+	ret = srv6_manager_release_sid(zclient, &ctx);
+	if (ret == ZCLIENT_SEND_FAILURE)
+		flog_err(EC_LIB_ZAPI_SOCKET,
+			 "zclient_send_get_srv6_sid() delete failed: %s",
+			 safe_strerror(errno));
+}
+
+/**
+ * Ask the SRv6 Manager (zebra) about a specific locator
+ *
+ * @param name Locator name
+ * @return 0 on success, -1 otherwise
+ */
+int static_zebra_srv6_manager_get_locator(const char *name)
+{
+	if (!name)
+		return -1;
+
+	/*
+	 * Send the Get Locator request to the SRv6 Manager and return the
+	 * result
+	 */
+	return srv6_manager_get_locator(zclient, name);
+}
+
+static void request_srv6_sids(struct static_srv6_locator *locator)
+{
+	struct static_srv6_sid *sid;
+	struct listnode *node;
+
+	for (ALL_LIST_ELEMENTS_RO(srv6_sids, node, sid)) {
+		if (sid->locator == locator)
+			static_zebra_request_srv6_sid(sid);
+	}
+}
+
+/**
+ * Internal function to process an SRv6 locator
+ *
+ * @param locator The locator to be processed
+ */
+static int static_zebra_process_srv6_locator_internal(struct srv6_locator *locator)
+{
+	struct static_srv6_locator *loc;
+	struct listnode *node;
+	struct static_srv6_sid *sid;
+
+	if (!locator)
+		return -1;
+
+	zlog_info("%s: Received SRv6 locator %s %pFX, loc-block-len=%u, loc-node-len=%u func-len=%u, arg-len=%u",
+		  __func__, locator->name, &locator->prefix,
+		  locator->block_bits_length, locator->node_bits_length,
+		  locator->function_bits_length, locator->argument_bits_length);
+
+	/* If we are already aware about the locator, nothing to do */
+	loc = static_srv6_locator_lookup(locator->name);
+	if (loc)
+		return 0;
+
+	loc = static_srv6_locator_alloc(locator->name);
+
+	zlog_info("SRv6 locator (locator %s, prefix %pFX) set",
+			locator->name, &locator->prefix);
+
+	/* Store the locator prefix */
+	loc->prefix = locator->prefix;
+	loc->block_bits_length = locator->block_bits_length;
+	loc->node_bits_length = locator->node_bits_length;
+	loc->function_bits_length = locator->function_bits_length;
+	loc->argument_bits_length = 0;
+	loc->flags = locator->flags;
+
+	listnode_add(srv6_locators, loc);
+
+	for (ALL_LIST_ELEMENTS_RO(srv6_sids, node, sid)) {
+		if (strncmp(sid->locator_name, loc->name, sizeof(loc->name)) == 0)
+			sid->locator = loc;
+	}
+
+	/* Request SIDs from the locator */
+	request_srv6_sids(loc);
+
+	return 0;
+}
+
+/**
+ * Callback to process an SRv6 locator received from SRv6 Manager (zebra).
+ *
+ * @result 0 on success, -1 otherwise
+ */
+static int static_zebra_process_srv6_locator_add(ZAPI_CALLBACK_ARGS)
+{
+	struct srv6_locator loc = {};
+
+	if (!srv6_locators)
+		return -1;
+
+	/* Decode the SRv6 locator */
+	if (zapi_srv6_locator_decode(zclient->ibuf, &loc) < 0)
+		return -1;
+
+	return static_zebra_process_srv6_locator_internal(&loc);
+}
+
+/**
+ * Callback to process a notification from SRv6 Manager (zebra) of an SRv6
+ * locator deleted.
+ *
+ * @result 0 on success, -1 otherwise
+ */
+static int static_zebra_process_srv6_locator_delete(ZAPI_CALLBACK_ARGS)
+{
+	struct srv6_locator loc = {};
+	struct listnode *node, *nnode;
+	struct listnode *node2, *nnode2;
+	struct static_srv6_sid *sid;
+	struct static_srv6_locator *locator;
+
+	if (!srv6_locators)
+		return -1;
+
+	/* Decode the received zebra message */
+	if (zapi_srv6_locator_decode(zclient->ibuf, &loc) < 0)
+		return -1;
+
+	zlog_info(
+		"SRv6 locator deleted in zebra: name %s, "
+		"prefix %pFX, block_len %u, node_len %u, func_len %u, arg_len %u",
+		loc.name, &loc.prefix, loc.block_bits_length,
+		loc.node_bits_length, loc.function_bits_length,
+		loc.argument_bits_length);
+
+	locator = static_srv6_locator_lookup(loc.name);
+	if (!locator)
+		return 0;
+
+	zlog_info("Deleting srv6 sids from locator %s", locator->name);
+
+	/* Delete SRv6 SIDs */
+	for (ALL_LIST_ELEMENTS(srv6_sids, node2, nnode2,
+					sid)) {
+
+		if (sid->locator != locator)
+			continue;
+
+		zlog_info(
+			"Deleting SRv6 SID (locator %s, sid %pFX)",
+			locator->name,
+			&sid->addr);
+
+		/* Uninstall the SRv6 SID from the forwarding plane
+			* through Zebra */
+		static_zebra_srv6_sid_uninstall(sid);
+	}
+
+	listnode_delete(srv6_locators, locator);
+	static_srv6_locator_free(locator);
+
+	return 0;
+}
+
+static int static_zebra_srv6_sid_notify(ZAPI_CALLBACK_ARGS)
+{
+	struct srv6_sid_ctx ctx;
+	struct in6_addr sid_addr;
+	enum zapi_srv6_sid_notify note;
+	uint32_t sid_func;
+	struct listnode *node;
+	char buf[256];
+	struct static_srv6_locator *locator;
+	struct prefix_ipv6 tmp_prefix;
+	struct static_srv6_sid *sid;
+	char *loc_name;
+
+	if (!srv6_locators)
+		return -1;
+
+	/* Decode the received notification message */
+	if (!zapi_srv6_sid_notify_decode(zclient->ibuf, &ctx, &sid_addr,
+					 &sid_func, NULL, &note, &loc_name)) {
+		zlog_err("%s : error in msg decode", __func__);
+		return -1;
+	}
+
+	zlog_info("%s: received SRv6 SID notify: ctx %s sid_value %pI6 sid_func %u note %s",
+		 __func__, srv6_sid_ctx2str(buf, sizeof(buf), &ctx), &sid_addr,
+		 sid_func, zapi_srv6_sid_notify2str(note));
+
+	/* Handle notification */
+	switch (note) {
+	case ZAPI_SRV6_SID_ALLOCATED:
+		zlog_info("SRv6 SID %pI6 %s ALLOCATED", &sid_addr,
+				srv6_sid_ctx2str(buf, sizeof(buf), &ctx));
+
+		bool found = false;
+		for (ALL_LIST_ELEMENTS_RO(srv6_sids, node, sid)) {
+			if (IPV6_ADDR_SAME(&sid->addr.prefix, &sid_addr)) {
+				found = true;
+				break;
+			}
+		}
+
+		if (!found) {
+			zlog_info("SRv6 SID %pI6 %s: not found", &sid_addr,
+				srv6_sid_ctx2str(buf, sizeof(buf), &ctx));
+			return 0;
+		}
+
+		/*
+			* Install the new SRv6 End SID in the forwarding plane through
+			* Zebra
+			*/
+		static_zebra_srv6_sid_install(sid);
+		
+		break;
+	case ZAPI_SRV6_SID_RELEASED:
+		zlog_info("SRv6 SID %pI6 %s: RELEASED", &sid_addr,
+				srv6_sid_ctx2str(buf, sizeof(buf), &ctx));
+		break;
+	case ZAPI_SRV6_SID_FAIL_ALLOC:
+		zlog_info("SRv6 SID %pI6 %s: Failed to allocate",
+				&sid_addr,
+				srv6_sid_ctx2str(buf, sizeof(buf), &ctx));
+
+		/* Error will be logged by zebra module */
+		break;
+	case ZAPI_SRV6_SID_FAIL_RELEASE:
+		zlog_warn("%s: SRv6 SID %pI6 %s failure to release",
+				__func__, &sid_addr,
+				srv6_sid_ctx2str(buf, sizeof(buf), &ctx));
+
+		/* Error will be logged by zebra module */
+		break;
+	}
+
+	return 0;
+}
+
 static zclient_handler *const static_handlers[] = {
 	[ZEBRA_INTERFACE_ADDRESS_ADD] = interface_address_add,
 	[ZEBRA_INTERFACE_ADDRESS_DELETE] = interface_address_delete,
 	[ZEBRA_ROUTE_NOTIFY_OWNER] = route_notify_owner,
+	[ZEBRA_SRV6_LOCATOR_ADD] = static_zebra_process_srv6_locator_add,
+	[ZEBRA_SRV6_LOCATOR_DELETE] = static_zebra_process_srv6_locator_delete,
+	[ZEBRA_SRV6_SID_NOTIFY] = static_zebra_srv6_sid_notify,
 };
 
 void static_zebra_init(void)
diff --git a/staticd/static_zebra.h b/staticd/static_zebra.h
index c4f4ebdcbc..7b00914499 100644
--- a/staticd/static_zebra.h
+++ b/staticd/static_zebra.h
@@ -7,6 +7,8 @@
 #ifndef __STATIC_ZEBRA_H__
 #define __STATIC_ZEBRA_H__
 
+#include "static_srv6.h"
+
 #ifdef __cplusplus
 extern "C" {
 #endif
@@ -22,8 +24,16 @@ extern void static_zebra_stop(void);
 extern void static_zebra_vrf_register(struct vrf *vrf);
 extern void static_zebra_vrf_unregister(struct vrf *vrf);
 
+extern int static_zebra_srv6_manager_get_locator(const char *name);
+
+extern void static_zebra_request_srv6_sid(struct static_srv6_sid *sid);
+extern void static_zebra_release_srv6_sid(struct static_srv6_sid *sid);
+
+extern void static_zebra_srv6_sid_install(struct static_srv6_sid *sid);
+extern void static_zebra_srv6_sid_uninstall(struct static_srv6_sid *sid);
+
 #ifdef __cplusplus
 }
 #endif
 
-#endif
+#endif
\ No newline at end of file
diff --git a/staticd/subdir.am b/staticd/subdir.am
index 07ebe3c02c..bdbacbdd68 100644
--- a/staticd/subdir.am
+++ b/staticd/subdir.am
@@ -19,6 +19,7 @@ staticd_libstatic_a_SOURCES = \
 	staticd/static_vty.c \
 	staticd/static_nb.c \
 	staticd/static_nb_config.c \
+	staticd/static_srv6.c \
 	# end
 
 noinst_HEADERS += \
@@ -29,6 +30,7 @@ noinst_HEADERS += \
 	staticd/static_vty.h \
 	staticd/static_vrf.h \
 	staticd/static_nb.h \
+	staticd/static_srv6.h \
 	# end
 
 clippy_scan += \
diff --git a/tests/topotests/static_srv6_sids/__init__.py b/tests/topotests/static_srv6_sids/__init__.py
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/tests/topotests/static_srv6_sids/expected_srv6_sids.json b/tests/topotests/static_srv6_sids/expected_srv6_sids.json
new file mode 100644
index 0000000000..e90709638f
--- /dev/null
+++ b/tests/topotests/static_srv6_sids/expected_srv6_sids.json
@@ -0,0 +1,142 @@
+{
+	"fcbb:bbbb:1::/48":[
+	   {
+		  "prefix":"fcbb:bbbb:1::/48",
+		  "prefixLen":48,
+		  "protocol":"static",
+		  "vrfId":0,
+		  "vrfName":"default",
+		  "selected":true,
+		  "destSelected":true,
+		  "distance":1,
+		  "metric":0,
+		  "installed":true,
+		  "table":254,
+		  "internalStatus":16,
+		  "internalFlags":9,
+		  "internalNextHopNum":1,
+		  "internalNextHopActiveNum":1,
+		  "nexthops":[
+			 {
+				"flags":3,
+				"fib":true,
+				"directlyConnected":true,
+				"interfaceName":"sr0",
+				"active":true,
+				"weight":1,
+				"seg6local":{
+				   "action":"End"
+				},
+				"seg6localContext":{
+				   "USP":true
+				}
+			 }
+		  ]
+	   }
+	],
+	"fcbb:bbbb:1:fe10::/64":[
+	   {
+		  "prefix":"fcbb:bbbb:1:fe10::/64",
+		  "prefixLen":64,
+		  "protocol":"static",
+		  "vrfId":0,
+		  "vrfName":"default",
+		  "selected":true,
+		  "destSelected":true,
+		  "distance":1,
+		  "metric":0,
+		  "installed":true,
+		  "table":254,
+		  "internalStatus":16,
+		  "internalFlags":9,
+		  "internalNextHopNum":1,
+		  "internalNextHopActiveNum":1,
+		  "nexthops":[
+			 {
+				"flags":3,
+				"fib":true,
+				"directlyConnected":true,
+				"interfaceName":"Vrf10",
+				"active":true,
+				"weight":1,
+				"seg6local":{
+				   "action":"End.DT4"
+				},
+				"seg6localContext":{
+				   "table":10
+				}
+			 }
+		  ]
+	   }
+	],
+	"fcbb:bbbb:1:fe20::/64":[
+	   {
+		  "prefix":"fcbb:bbbb:1:fe20::/64",
+		  "prefixLen":64,
+		  "protocol":"static",
+		  "vrfId":0,
+		  "vrfName":"default",
+		  "selected":true,
+		  "destSelected":true,
+		  "distance":1,
+		  "metric":0,
+		  "installed":true,
+		  "table":254,
+		  "internalStatus":16,
+		  "internalFlags":9,
+		  "internalNextHopNum":1,
+		  "internalNextHopActiveNum":1,
+		  "nexthops":[
+			 {
+				"flags":3,
+				"fib":true,
+				"directlyConnected":true,
+				"interfaceName":"Vrf20",
+				"active":true,
+				"weight":1,
+				"seg6local":{
+				   "action":"End.DT6"
+				},
+				"seg6localContext":{
+				   "table":20
+				}
+			 }
+		  ]
+	   }
+	],
+	"fcbb:bbbb:1:fe30::/64":[
+	   {
+		  "prefix":"fcbb:bbbb:1:fe30::/64",
+		  "prefixLen":64,
+		  "protocol":"static",
+		  "vrfId":0,
+		  "vrfName":"default",
+		  "selected":true,
+		  "destSelected":true,
+		  "distance":1,
+		  "metric":0,
+		  "installed":true,
+		  "table":254,
+		  "internalStatus":16,
+		  "internalFlags":9,
+		  "internalNextHopNum":1,
+		  "internalNextHopActiveNum":1,
+		  "nexthops":[
+			 {
+				"flags":3,
+				"fib":true,
+				"directlyConnected":true,
+				"interfaceName":"Vrf30",
+				"active":true,
+				"weight":1,
+				"seg6local":{
+				   "action":"End.DT46"
+				},
+				"seg6localContext":{
+				   "table":30
+				}
+			 }
+		  ]
+	   }
+	]
+ }
\ No newline at end of file
diff --git a/tests/topotests/static_srv6_sids/r1/mgmtd.conf b/tests/topotests/static_srv6_sids/r1/mgmtd.conf
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/tests/topotests/static_srv6_sids/r1/setup.sh b/tests/topotests/static_srv6_sids/r1/setup.sh
new file mode 100644
index 0000000000..040be73914
--- /dev/null
+++ b/tests/topotests/static_srv6_sids/r1/setup.sh
@@ -0,0 +1,13 @@
+ip link add sr0 type dummy
+ip link set sr0 up
+
+ip link add Vrf10 type vrf table 10
+ip link set Vrf10 up
+
+ip link add Vrf20 type vrf table 20
+ip link set Vrf20 up
+
+ip link add Vrf30 type vrf table 30
+ip link set Vrf30 up
+
+sysctl -w net.vrf.strict_mode=1
diff --git a/tests/topotests/static_srv6_sids/r1/staticd.conf b/tests/topotests/static_srv6_sids/r1/staticd.conf
new file mode 100644
index 0000000000..96d2f4e9a6
--- /dev/null
+++ b/tests/topotests/static_srv6_sids/r1/staticd.conf
@@ -0,0 +1,16 @@
+hostname r1
+!
+log stdout notifications
+log commands
+log file staticd.log debugging
+!
+segment-routing
+ srv6
+  static-sids
+   sid fcbb:bbbb:1::/48 locator MAIN behavior uN
+   sid fcbb:bbbb:1:fe10::/64 locator MAIN behavior uDT4 vrf Vrf10
+   sid fcbb:bbbb:1:fe20::/64 locator MAIN behavior uDT6 vrf Vrf20
+   sid fcbb:bbbb:1:fe30::/64 locator MAIN behavior uDT46 vrf Vrf30
+  !
+ !
+!
diff --git a/tests/topotests/static_srv6_sids/r1/zebra.conf b/tests/topotests/static_srv6_sids/r1/zebra.conf
new file mode 100644
index 0000000000..cf73e23744
--- /dev/null
+++ b/tests/topotests/static_srv6_sids/r1/zebra.conf
@@ -0,0 +1,19 @@
+hostname r1
+!
+! debug zebra events
+! debug zebra rib detailed
+!
+log stdout notifications
+log commands
+log file zebra.log debugging
+!
+segment-routing
+ srv6
+  locators
+   locator MAIN
+    prefix fcbb:bbbb:1::/48 block-len 32 node-len 16 func-bits 16
+    behavior usid
+   !
+  !
+ !
+!
\ No newline at end of file
diff --git a/tests/topotests/static_srv6_sids/test_static_srv6_sids.py b/tests/topotests/static_srv6_sids/test_static_srv6_sids.py
new file mode 100755
index 0000000000..195ecf9385
--- /dev/null
+++ b/tests/topotests/static_srv6_sids/test_static_srv6_sids.py
@@ -0,0 +1,89 @@
+#!/usr/bin/env python
+# SPDX-License-Identifier: ISC
+
+#
+# test_static_srv6_sids.py
+#
+# Copyright 2025 Carmine Scarpitta
+#
+
+"""
+test_static_srv6_sids.py:
+Test for SRv6 static route on zebra
+"""
+
+import os
+import sys
+import json
+import pytest
+import functools
+
+CWD = os.path.dirname(os.path.realpath(__file__))
+sys.path.append(os.path.join(CWD, "../"))
+
+# pylint: disable=C0413
+from lib import topotest
+from lib.topogen import Topogen, TopoRouter, get_topogen
+from lib.topolog import logger
+
+pytestmark = [pytest.mark.staticd]
+
+
+def open_json_file(filename):
+    try:
+        with open(filename, "r") as f:
+            return json.load(f)
+    except IOError:
+        assert False, "Could not read file {}".format(filename)
+
+
+def setup_module(mod):
+    tgen = Topogen({None: "r1"}, mod.__name__)
+    tgen.start_topology()
+    for rname, router in tgen.routers().items():
+        router.run("/bin/bash {}/{}/setup.sh".format(CWD, rname))
+        router.load_config(
+            TopoRouter.RD_ZEBRA, os.path.join(CWD, "{}/zebra.conf".format(rname))
+        )
+        router.load_config(
+            TopoRouter.RD_MGMTD, os.path.join(CWD, "{}/mgmtd.conf".format(rname))
+        )
+        router.load_config(
+            TopoRouter.RD_STATIC, os.path.join(CWD, "{}/staticd.conf".format(rname))
+        )
+    tgen.start_router()
+
+
+def teardown_module():
+    tgen = get_topogen()
+    tgen.stop_topology()
+
+
+def test_srv6_static_sids():
+    tgen = get_topogen()
+    if tgen.routers_have_failure():
+        pytest.skip(tgen.errors)
+    router = tgen.gears["r1"]
+
+    def _check_srv6_static_sids(router, expected_route_file):
+        logger.info("checking zebra srv6 static sids")
+        output = json.loads(router.vtysh_cmd("show ipv6 route static json"))
+        expected = open_json_file("{}/{}".format(CWD, expected_route_file))
+        return topotest.json_cmp(output, expected)
+
+    def check_srv6_static_sids(router, expected_file):
+        func = functools.partial(_check_srv6_static_sids, router, expected_file)
+        _, result = topotest.run_and_expect(func, None, count=15, wait=1)
+        assert result is None, "Failed"
+
+    # FOR DEVELOPER:
+    # If you want to stop some specific line and start interactive shell,
+    # please use tgen.mininet_cli() to start it.
+
+    logger.info("Test for srv6 sids configuration")
+    check_srv6_static_sids(router, "expected_srv6_sids.json")
+
+
+if __name__ == "__main__":
+    args = ["-s"] + sys.argv[1:]
+    sys.exit(pytest.main(args))
diff --git a/vtysh/vtysh.c b/vtysh/vtysh.c
index c460dea70c..a1b16c2b66 100644
--- a/vtysh/vtysh.c
+++ b/vtysh/vtysh.c
@@ -1312,6 +1312,13 @@ static struct cmd_node srv6_node = {
 	.prompt = "%s(config-srv6)# ",
 };
 
+static struct cmd_node srv6_sids_node = {
+	.name = "srv6-sids",
+	.node = SRV6_SIDS_NODE,
+	.parent_node = SRV6_NODE,
+	.prompt = "%s(config-srv6-sids)# ",
+};
+
 static struct cmd_node srv6_locs_node = {
 	.name = "srv6-locators",
 	.node = SRV6_LOCS_NODE,
@@ -1685,7 +1692,7 @@ DEFUNSH(VTYSH_REALLYALL, vtysh_end_all, vtysh_end_all_cmd, "end",
 	return vtysh_end();
 }
 
-DEFUNSH(VTYSH_ZEBRA, srv6, srv6_cmd,
+DEFUNSH(VTYSH_ZEBRA | VTYSH_MGMTD, srv6, srv6_cmd,
 	"srv6",
 	"Segment-Routing SRv6 configuration\n")
 {
@@ -1693,6 +1700,14 @@ DEFUNSH(VTYSH_ZEBRA, srv6, srv6_cmd,
 	return CMD_SUCCESS;
 }
 
+DEFUNSH(VTYSH_MGMTD, srv6_sids, srv6_sids_cmd,
+	"static-sids",
+	"Segment-Routing SRv6 SIDs configuration\n")
+{
+	vty->node = SRV6_SIDS_NODE;
+	return CMD_SUCCESS;
+}
+
 DEFUNSH(VTYSH_ZEBRA, srv6_locators, srv6_locators_cmd,
 	"locators",
 	"Segment-Routing SRv6 locators configuration\n")
@@ -2216,7 +2231,7 @@ DEFUNSH(VTYSH_FABRICD, router_openfabric, router_openfabric_cmd, "router openfab
 }
 #endif /* HAVE_FABRICD */
 
-DEFUNSH(VTYSH_SR, segment_routing, segment_routing_cmd,
+DEFUNSH(VTYSH_SR | VTYSH_MGMTD, segment_routing, segment_routing_cmd,
 	"segment-routing",
 	"Configure segment routing\n")
 {
@@ -2535,7 +2550,7 @@ DEFUNSH(VTYSH_VRF, exit_vrf_config, exit_vrf_config_cmd, "exit-vrf",
 	return CMD_SUCCESS;
 }
 
-DEFUNSH(VTYSH_ZEBRA, exit_srv6_config, exit_srv6_config_cmd, "exit",
+DEFUNSH(VTYSH_ZEBRA | VTYSH_MGMTD, exit_srv6_config, exit_srv6_config_cmd, "exit",
 	"Exit from SRv6 configuration mode\n")
 {
 	if (vty->node == SRV6_NODE)
@@ -2551,6 +2566,14 @@ DEFUNSH(VTYSH_ZEBRA, exit_srv6_locs_config, exit_srv6_locs_config_cmd, "exit",
 	return CMD_SUCCESS;
 }
 
+DEFUNSH(VTYSH_MGMTD, exit_srv6_sids_config, exit_srv6_sids_config_cmd, "exit",
+	"Exit from SRv6-SIDs configuration mode\n")
+{
+	if (vty->node == SRV6_SIDS_NODE)
+		vty->node = SRV6_NODE;
+	return CMD_SUCCESS;
+}
+
 DEFUNSH(VTYSH_ZEBRA, exit_srv6_loc_config, exit_srv6_loc_config_cmd, "exit",
 	"Exit from SRv6-locators configuration mode\n")
 {
@@ -2806,13 +2829,13 @@ DEFUNSH(VTYSH_KEYS, vtysh_quit_keys, vtysh_quit_keys_cmd, "quit",
 	return vtysh_exit_keys(self, vty, argc, argv);
 }
 
-DEFUNSH(VTYSH_SR, vtysh_exit_sr, vtysh_exit_sr_cmd, "exit",
+DEFUNSH(VTYSH_SR | VTYSH_MGMTD, vtysh_exit_sr, vtysh_exit_sr_cmd, "exit",
 	"Exit current mode and down to previous mode\n")
 {
 	return vtysh_exit(vty);
 }
 
-DEFUNSH(VTYSH_SR, vtysh_quit_sr, vtysh_quit_sr_cmd, "quit",
+DEFUNSH(VTYSH_SR | VTYSH_MGMTD, vtysh_quit_sr, vtysh_quit_sr_cmd, "quit",
 	"Exit current mode and down to previous mode\n")
 {
 	return vtysh_exit(vty);
@@ -4999,6 +5022,7 @@ void vtysh_init_vty(void)
 	install_node(&rmap_node);
 	install_node(&vty_node);
 	install_node(&srv6_node);
+	install_node(&srv6_sids_node);
 	install_node(&srv6_locs_node);
 	install_node(&srv6_loc_node);
 	install_node(&srv6_encap_node);
@@ -5442,6 +5466,10 @@ void vtysh_init_vty(void)
 	install_element(SRV6_NODE, &exit_srv6_config_cmd);
 	install_element(SRV6_NODE, &vtysh_end_all_cmd);
 	install_element(SRV6_NODE, &srv6_encap_cmd);
+	install_element(SRV6_NODE, &srv6_sids_cmd);
+
+	install_element(SRV6_SIDS_NODE, &exit_srv6_sids_config_cmd);
+	install_element(SRV6_SIDS_NODE, &vtysh_end_all_cmd);
 
 	install_element(SRV6_LOCS_NODE, &srv6_locator_cmd);
 	install_element(SRV6_LOCS_NODE, &exit_srv6_locs_config_cmd);
diff --git a/yang/frr-staticd.yang b/yang/frr-staticd.yang
index 1e6c54c006..ac3b04dede 100644
--- a/yang/frr-staticd.yang
+++ b/yang/frr-staticd.yang
@@ -92,6 +92,41 @@ module frr-staticd {
     }
   }
 
+  typedef srv6-behavior {
+    type enumeration {
+      enum end {
+        value 1;
+      }
+      enum end-x {
+        value 2;
+      }
+      enum end-dt6 {
+        value 3;
+      }
+      enum end-dt4 {
+        value 4;
+      }
+      enum end-dt46 {
+        value 5;
+      }
+      enum un {
+        value 6;
+      }
+      enum ua {
+        value 7;
+      }
+      enum udt6 {
+        value 8;
+      }
+      enum udt4 {
+        value 9;
+      }
+      enum udt46 {
+        value 10;
+      }
+    }
+  }
+
   augment "/frr-rt:routing/frr-rt:control-plane-protocols/frr-rt:control-plane-protocol" {
     container staticd {
       when "../frr-rt:type = 'frr-staticd:staticd'" {
@@ -144,6 +179,28 @@ module frr-staticd {
           uses staticd-prefix-attributes;
         }
       }
+
+      container segment-routing {
+        container srv6 {
+          container local-sids {
+            list sid {
+              key "sid";
+              leaf sid {
+                type inet:ipv6-prefix;
+              }
+              leaf behavior {
+                type srv6-behavior;
+              }
+              leaf locator-name {
+                type string;
+              }
+              leaf vrf-name {
+                type string;
+              }
+            }
+          }
+        }
+      }
     }
   }
-}
+}
\ No newline at end of file
diff --git a/zebra/zebra_srv6.c b/zebra/zebra_srv6.c
index 624f60e815..e14cc1f5c1 100644
--- a/zebra/zebra_srv6.c
+++ b/zebra/zebra_srv6.c
@@ -1488,14 +1488,15 @@ static bool alloc_srv6_sid_func_dynamic(struct zebra_srv6_sid_block *block,
  */
 static int get_srv6_sid_explicit(struct zebra_srv6_sid **sid,
 				 struct srv6_sid_ctx *ctx,
-				 struct in6_addr *sid_value)
+				 struct in6_addr *sid_value,
+				 struct srv6_locator *loc)
 {
 	struct zebra_srv6 *srv6 = zebra_srv6_get_default();
 	struct zebra_srv6_sid_ctx *s = NULL;
 	struct zebra_srv6_sid_ctx *zctx = NULL;
 	struct listnode *node;
 	uint32_t sid_func = 0, sid_func_wide = 0;
-	struct srv6_locator *locator = NULL;
+	struct srv6_locator *locator = loc;
 	struct zebra_srv6_sid_block *block = NULL;
 	char buf[256];
 
@@ -1524,7 +1525,7 @@ static int get_srv6_sid_explicit(struct zebra_srv6_sid **sid,
 			 * It is not allowed to allocate an explicit SID for a given context if the context
 			 * is already associated with an explicit SID
 			 */
-			if (s->sid->alloc_mode == SRV6_SID_ALLOC_MODE_EXPLICIT) {
+			if (s->ctx.behavior != ZEBRA_SEG6_LOCAL_ACTION_END && s->sid->alloc_mode == SRV6_SID_ALLOC_MODE_EXPLICIT) {
 				zlog_err("%s: cannot alloc SID %pI6 for ctx %s: ctx already associated with SID %pI6",
 					 __func__, sid_value,
 					 srv6_sid_ctx2str(buf, sizeof(buf),
@@ -1538,18 +1539,106 @@ static int get_srv6_sid_explicit(struct zebra_srv6_sid **sid,
 		}
 	}
 
-	/* Get parent locator and function of the provided SID */
-	if (!zebra_srv6_sid_decompose(sid_value, &block, &locator, &sid_func,
-				      &sid_func_wide)) {
-		zlog_err("%s: invalid SM request arguments: parent block/locator not found for SID %pI6",
-			 __func__, sid_value);
-		return -1;
+	if (!locator) {
+		/* Get parent locator and function of the provided SID */
+		if (!zebra_srv6_sid_decompose(sid_value, &block, &locator, &sid_func,
+						&sid_func_wide)) {
+			zlog_err("%s: invalid SM request arguments: parent block/locator not found for SID %pI6",
+				__func__, sid_value);
+			return -1;
+		}
+	} else {
+		struct prefix_ipv6 tmp_prefix;
+		struct srv6_sid_format *format = locator->sid_format;
+		uint8_t offset, func_len;
+
+		/*
+		* Build a temporary prefix_ipv6 object representing the SRv6 SID.
+		* This temporary prefix object is used below by the prefix_match
+		* function to check if the SID belongs to a specific locator.
+		*/
+		tmp_prefix.family = AF_INET6;
+		tmp_prefix.prefixlen = IPV6_MAX_BITLEN;
+		tmp_prefix.prefix = *sid_value;
+
+		/*
+		 * Check if the locator prefix includes the temporary prefix
+		 * representing the SID.
+		 */
+		if (!prefix_match((struct prefix *)&locator->prefix,
+				 (struct prefix *)&tmp_prefix)) {
+			zlog_err("%s: invalid SM request arguments: SID %pI6 does not belong to the specified locator '%s'",
+					__func__, sid_value, locator->name);
+			return -1;
+		}
+
+		if (format) {
+			offset = format->block_len + format->node_len;
+			func_len = format->function_len;
+		} else {
+			offset = locator->block_bits_length +
+					locator->node_bits_length;
+			func_len = locator->function_bits_length;
+		}
+
+		for (uint8_t idx = 0; idx < func_len; idx++) {
+			uint8_t tidx = offset + idx;
+			sid_func |= (sid_value->s6_addr[tidx / 8] &
+						(0x1 << (7 - tidx % 8)))
+						<< (((func_len - 1 - idx) / 8) * 8);
+		}
+
+		/*
+			* If function comes from the Wide LIB range, we also
+			* need to get the Wide function.
+			*/
+		if (format && format->type == SRV6_SID_FORMAT_TYPE_USID) {
+			if (sid_func >= format->config.usid.wlib_start &&
+				sid_func <= format->config.usid.wlib_end) {
+				format = locator->sid_format;
+
+				offset = format->block_len +
+						format->node_len +
+						format->function_len;
+
+				for (uint8_t idx = 0; idx < 16; idx++) {
+					uint8_t tidx = offset + idx;
+					sid_func_wide |=
+						(sid_value->s6_addr[tidx /
+									8] &
+							(0x1 << (7 - tidx % 8)))
+						<< (((16 - 1 - idx) / 8) *
+							8);
+				}
+			}
+		}
+
+		block = locator->sid_block;
 	}
 
 	if (ctx->behavior == ZEBRA_SEG6_LOCAL_ACTION_END) {
-		zlog_err("%s: invalid SM request arguments: explicit SID allocation not allowed for End/uN behavior",
-			 __func__);
-		return -1;
+		zctx = zebra_srv6_sid_ctx_alloc();
+		zctx->ctx = *ctx;
+
+		/* Allocate the SID to store SID information */
+		*sid = zebra_srv6_sid_alloc(zctx, sid_value, locator, block, sid_func,
+						SRV6_SID_ALLOC_MODE_EXPLICIT);
+		if (!(*sid)) {
+			flog_err(EC_ZEBRA_SM_CANNOT_ASSIGN_SID,
+				"%s: failed to create SRv6 SID %s (%pI6)", __func__,
+				srv6_sid_ctx2str(buf, sizeof(buf), ctx), sid_value);
+			return -1;
+		}
+		(*sid)->ctx = zctx;
+		zctx->sid = *sid;
+		listnode_add(srv6->sids, zctx);
+
+		if (IS_ZEBRA_DEBUG_PACKET)
+			zlog_debug("%s: allocated explicit SRv6 SID %pI6 for context %s",
+				__func__, &(*sid)->value,
+				srv6_sid_ctx2str(buf, sizeof(buf), ctx));
+
+		return 1;
 	}
 
 	/* Allocate an explicit SID function for the SID */
@@ -1749,7 +1838,16 @@ int get_srv6_sid(struct zebra_srv6_sid **sid, struct srv6_sid_ctx *ctx,
 			return -1;
 		}
 
-		ret = get_srv6_sid_explicit(sid, ctx, sid_value);
+		if (locator_name) {
+			locator = zebra_srv6_locator_lookup(locator_name);
+			if (!locator) {
+				zlog_err("%s: invalid SM request arguments: SRv6 locator '%s' does not exist",
+						__func__, locator_name);
+				return -1;
+			}
+		}
+
+		ret = get_srv6_sid_explicit(sid, ctx, sid_value, locator);
 
 		break;
 	case SRV6_SID_ALLOC_MODE_DYNAMIC:
-- 
2.45.2

